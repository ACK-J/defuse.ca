<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>The Code Files</title><link href="/blog/" rel="alternate"></link><link href="/blog/feeds/security.atom.xml" rel="self"></link><id>/blog/</id><updated>2013-08-09T00:00:00-06:00</updated><entry><title>Enabling TLS v1.1 on Firefox 23</title><link href="/blog/enabling-tls-11-on-firefox-version-23.html" rel="alternate"></link><updated>2013-08-09T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2013-08-09:enabling-tls-11-on-firefox-version-23.html</id><summary type="html">&lt;p&gt;Change the following settings in Firefox's &lt;a class="reference external" href="about:config"&gt;about:config&lt;/a&gt; to enable TLS v1.1.&lt;/p&gt;
&lt;img alt="Enabling TLS 1.1 in Firefox 23" src="https://defuse.ca/images/ff23-tls.png" /&gt;
&lt;p&gt;&lt;strong&gt;Steps&lt;/strong&gt;&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Open a new tab and type &lt;a class="reference external" href="about:config"&gt;about:config&lt;/a&gt; into the address bar.&lt;/li&gt;
&lt;li&gt;Search for tls.version.&lt;/li&gt;
&lt;li&gt;Set security.tls.version.max to 2. This enables TLS 1.1.&lt;/li&gt;
&lt;li&gt;Set security.tls.version.min to 1. This disables SSL 3.0.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Be aware that setting tls.version.max to 3 will enable TLS v1.2 in a future
release of Firefox, but setting it to 3 in version 23 actually makes it fall
back to using &lt;em&gt;only&lt;/em&gt; TLS 1.0. So for now, set it to 2.&lt;/p&gt;
&lt;p&gt;The image was contributed by &lt;a class="reference external" href="https://twitter.com/voodooKobra"&gt;&amp;#64;voodooKobra&lt;/a&gt;.&lt;/p&gt;
</summary><category term="firefox"></category></entry><entry><title>What is DDoS? (Guest Post)</title><link href="/blog/what-is-ddos.html" rel="alternate"></link><updated>2013-05-12T00:00:00-06:00</updated><author><name>Breshie</name></author><id>tag:/blog,2013-05-12:what-is-ddos.html</id><summary type="html">&lt;p&gt;This is a guest post by BreShiE.&lt;/p&gt;
&lt;p&gt;DDoS attacks are becoming more and more frequent in today's world, with any
average person being able to download or purchase such tools from online, public
forums. You may have heard about the self proclaimed hacktivist group
&amp;quot;Anonymous&amp;quot; and their infamous take-downs of websites such as &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Operation_Payback"&gt;MasterCard,
PayPal and The Bank of America&lt;/a&gt;. Well, these websites were taken offline for
a period of time by an attack known as &amp;quot;DDoS&amp;quot;, but what is DDoS?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DDoS&lt;/strong&gt; stands for &lt;strong&gt;Distributed Denial of Service&lt;/strong&gt;. DDoS attacks work by
collecting multiple infected machines or servers with certain scripts, or
malware, intended to send data from the infected server or home connection to
a victims. This means the attacker can overload the victim connection, by
flooding it with loads and loads of dummy data, eventually causing the victim
connection to overload, &amp;quot;knocking&amp;quot; the connection offline and making it
unresponsive. See the below diagram for an example of this:&lt;/p&gt;
&lt;img alt="DDoS diagram" src="/images/breshie-ddos.png" /&gt;
&lt;p&gt;As you can see from the above diagram, the attacker sends a command to the
servers/PCs that are under his/her control, which then send the dummy data to
the victim connection and overloads the connection, making it hard or impossible
for the victim's users to communicate with the victim. There's also what is
known as &amp;quot;DoS&amp;quot; which is often not as strong as a DDoS attack, but if the
attacker is using a server with a strong connection, this attack can still be
devastating. One thing to &lt;strong&gt;note&lt;/strong&gt; would be that there are companies which fight
to prevent this exact attack and that is why you never see big sites like eBay,
YouTube and Google go down. With this &lt;a class="reference external" href="http://www.bbc.co.uk/news/technology-17472447"&gt;huge scare about &amp;quot;hackers being able to
take down the internet&amp;quot;&lt;/a&gt;, it's baloney. The only way it would be possible, is
if the data-centers were to be physically blown up, not DDoS attacks via the
internet.  If you wish to know more on this subject, visit &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Distributed_denial_of_service#Distributed_attack"&gt;Wikipedia's page on
DDoS&lt;/a&gt;&lt;/p&gt;
</summary><category term="ddos"></category></entry><entry><title>[Ruby] Password Training Script</title><link href="/blog/ruby-password-training-script.html" rel="alternate"></link><updated>2013-03-28T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2013-03-28:ruby-password-training-script.html</id><summary type="html">&lt;p&gt;This is a simple Ruby script that helps you memorize a password by making you
type it over and over again. It first breaks the password into chunks of
4 characters, helps you to memorize each chunk, then every consecutive pair of
chunks, then every consecutive triple... and so on, until you're typing the
entire password from memory.&lt;/p&gt;
&lt;p&gt;I was able to completely memorize a 131-bit password (20 printable ASCII
characters, completely random) in about 20 minutes using this script.&lt;/p&gt;
&lt;p&gt;You'll need the 'highline' gem to run this script: &lt;tt class="docutils literal"&gt;gem install highline&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="code ruby literal-block"&gt;
&lt;span class="c1"&gt;# Ruby Password Trainer&lt;/span&gt;

&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'highline/import'&lt;/span&gt;

&lt;span class="no"&gt;TIMES_TO_TYPE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="no"&gt;CHUNK_SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is a script that helps you memorize a password.&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;WARNING: Make sure nobody is watching you while you use this script!&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;Your password: &amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;gets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;chop&lt;/span&gt;
&lt;span class="n"&gt;password_chunks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each_slice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="no"&gt;CHUNK_SIZE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_a&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gets_noecho&lt;/span&gt;
  &lt;span class="n"&gt;ask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;false&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;clear&lt;/span&gt;
  &lt;span class="nb"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;clear&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;continue?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Round &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; finished. Again? [Y/n] &amp;quot;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;gets&lt;/span&gt; &lt;span class="o"&gt;=~&lt;/span&gt; &lt;span class="sr"&gt;/^y$/i&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;chunks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_chunks&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_chunks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;password_chunks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each_cons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;num_chunks&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;portion&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="n"&gt;part&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;portion&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# Training&lt;/span&gt;
    &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;TIMES_TO_TYPE&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Type &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s2"&gt;  &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; times...&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gets_noecho&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;WRONG! You typed &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
      &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="c1"&gt;# Recall test&lt;/span&gt;
    &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;TIMES_TO_TYPE&lt;/span&gt;
    &lt;span class="n"&gt;wrong&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;false&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;wrong&lt;/span&gt;
      &lt;span class="n"&gt;clear&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Type the same thing &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; times...&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gets_noecho&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;
        &lt;span class="n"&gt;wrong&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
      &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;gt;&amp;gt; You got &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="no"&gt;TIMES_TO_TYPE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="no"&gt;TIMES_TO_TYPE&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; right.&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;wrong&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Try again...&amp;quot;&lt;/span&gt;
      &lt;span class="k"&gt;redo&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;round&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
  &lt;span class="n"&gt;clear&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;password_chunks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;num_chunks&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="n"&gt;chunks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_chunks&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_chunks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;round&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;continue?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;round&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
</summary><category term="ruby"></category><category term="passwords"></category></entry><entry><title>Windows Magnifier Hack</title><link href="/blog/windows-magnifier-password-reset.rst.html" rel="alternate"></link><updated>2013-02-19T00:00:00-07:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2013-02-19:windows-magnifier-password-reset.rst.html</id><summary type="html">&lt;p&gt;Steps to reset a Windows account password given physical access to the box:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Boot a Linux live cd and mount C:somewhere.&lt;/li&gt;
&lt;li&gt;Find magnifier.exe (somewhere in System32) and replace it with cmd.exe.&lt;/li&gt;
&lt;li&gt;Boot to the Windows login screen.&lt;/li&gt;
&lt;li&gt;Press WinKey + U&lt;/li&gt;
&lt;li&gt;Start the magnifier, which should run cmd.exe.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://support.microsoft.com/kb/149427"&gt;Change the password in the Command Prompt&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that this will destroy all data encrypted with &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Encrypting_File_System"&gt;EFS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I'm not sure who thought of this first, but if I knew, I would credit them here.&lt;/p&gt;
</summary><category term="windows"></category></entry><entry><title>Encrypted Automatic Backups with Public Key Cryptography</title><link href="/blog/encrypted-automatic-backups-with-pkc.html" rel="alternate"></link><updated>2012-12-16T00:00:00-07:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-12-16:encrypted-automatic-backups-with-pkc.html</id><summary type="html">&lt;p&gt;Here's how to do encrypted automated backups without having to store the
password in the backup script. The script should be self-explanatory (after all,
it is 50 lines of comments for just one real line of code).&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
&lt;span class="c"&gt;#!/bin/bash
# File name: backup.sh
# This script automates the process of encrypting a directory for backup.
#
# Instead of using normal password encryption, we take advantage of public-key
# cryptography so that you don't need to include the password in the encryption
# script. This is required if you want to have files automatically encrypted
# with a password remembered only by your biological brain.
#
# It requires a bit of setup:
#
# 1. Generate a public/private key pair (as the user that will run this script):
#   - Run,
#      $ gpg --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-mode 3  \
#        --s2k-count 65011712 --gen-key
#   - Choose the &amp;quot;RSA and RSA&amp;quot; key type.
#   - Choose 4096 (or greater) as the key size.
#   - Enter an expiration time of 0 (never expires)
#   - Give the key a name (enter 'invalid&amp;#64;invalid.invalid' for the email).
#   - Enter a password. This is the password that you will need to decrypt the
#     backup files.
#
# 2. Modify the constants in this script:
#   - DIRECTORY:
#       Set this to the folder you want to automatically encrypt.
#   - GPG_RECIPIENT
#       Set this to the ID of the public key generated in step 1.
#       You can find the ID by running
#           $ gpg --list-keys
#       It is the 8-digit hexadecimal number on the 'pub' line corresponding to
#       your key.
#   - OUTPUT_FILE
#       Where to put the encrypted GPG file.
#       If the file already exists, it will be overwritten.
#
# 3. Backup your public key and (encrypted) private key.
#   To decrypt the file that this script generates, you will need the private
#   key and the password you gave in step 1, so it is a good idea to make
#   a backup of your key pair.
#
#   To backup your public key:
#       $ gpg -a --export NAME &amp;gt; public_key.txt
#   To backup your private key:
#       $ gpg -a --export-secret-keys NAME &amp;gt; private_key.txt
#   ...where NAME is part of the name you gave in step 1.
#
#   Because the private key is encrypted with the password, it is safe to store
#   the key backups with the backup file (or even publish them).
#
# DECRYPTING:
#   To decrypt the file generated by this script, run:
#       $ gpg -d -o decrypted.tar &amp;lt;backup file&amp;gt;
#       $ tar xvf decrypted.tar
&lt;/span&gt;
&lt;span class="nb"&gt;readonly &lt;/span&gt;&lt;span class="nv"&gt;DIRECTORY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;./testing                    &lt;span class="c"&gt;# Directory to encrypt.
&lt;/span&gt;&lt;span class="nb"&gt;readonly &lt;/span&gt;&lt;span class="nv"&gt;GPG_RECIPIENT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;EAD91475                 &lt;span class="c"&gt;# Public key ID.
&lt;/span&gt;&lt;span class="nb"&gt;readonly &lt;/span&gt;&lt;span class="nv"&gt;OUTPUT_FILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/tmp/encrypted.tar.gpg     &lt;span class="c"&gt;# Encrypted file path.
&lt;/span&gt;
tar cf - -C &lt;span class="nv"&gt;$DIRECTORY&lt;/span&gt; . | &lt;span class="se"&gt;\
&lt;/span&gt;    gpg -z 9 --batch --yes --encrypt --recipient &lt;span class="nv"&gt;$GPG_RECIPIENT&lt;/span&gt; --output &lt;span class="nv"&gt;$OUTPUT_FILE&lt;/span&gt;
&lt;/pre&gt;
</summary><category term="backups"></category></entry><entry><title>Increasing Collisions in Password Hashing</title><link href="/blog/increasing-collisions-in-password-hashing.html" rel="alternate"></link><updated>2012-12-11T00:00:00-07:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-12-11:increasing-collisions-in-password-hashing.html</id><summary type="html">&lt;p&gt;With this post I will try to show how, in a theoretical scenario, deliberately
weakening the collision resistance of a password hash function can increase
security. This is by no means a formal proof.&lt;/p&gt;
&lt;p&gt;Suppose Alice has an account on two computer systems &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt;. She uses the
same password on both systems.&lt;/p&gt;
&lt;p&gt;Suppose both systems implement the following password hashing scheme: Let &lt;em&gt;t&lt;/em&gt; be
some positive integer. Given a password &lt;em&gt;P&lt;/em&gt;, compute the entropy of the password
&lt;em&gt;H(P)&lt;/em&gt;. Create and store a salted &lt;em&gt;B&lt;/em&gt;-bit hash of &lt;em&gt;P&lt;/em&gt; where &lt;em&gt;B = H(P) - lg(t)&lt;/em&gt;.
To verify a password, wait for &lt;em&gt;t&lt;/em&gt; units of time then check the hash in the
usual manner. Here, the entropy of the password is the logarithm base two of the
number of guesses it will take an adversary to guess the exact password. Also
suppose that it takes one unit of time to compute a hash.&lt;/p&gt;
&lt;p&gt;I claim that using this scheme, Alice's accounts are no less secure than if we
used 256-bit hashes (if &lt;em&gt;H(P) &amp;lt; 256&lt;/em&gt;), and that if System &lt;em&gt;X&lt;/em&gt; gets compromised,
then her account on System &lt;em&gt;Y&lt;/em&gt; is more secure than if we used 256-bit hashes.&lt;/p&gt;
&lt;p&gt;To see why, note two things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The probability of any random string &lt;em&gt;S&lt;/em&gt; having the same hash as Alice's
password &lt;em&gt;P&lt;/em&gt; is &lt;em&gt;1/(2^B)&lt;/em&gt;. So if Mallory tries to guess Alice's password
using an online attack, it will take about &lt;em&gt;2^B&lt;/em&gt; guesses, so about &lt;em&gt;2^B * t&lt;/em&gt;
time. So the effective security against an online attack is &lt;em&gt;B + lg(t)&lt;/em&gt;. By
the construction, &lt;em&gt;B + lg(t) = H(P)&lt;/em&gt; so this is no easier than guessing &lt;em&gt;P&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Suppose Mallory roots System &lt;em&gt;X&lt;/em&gt; and gets the &lt;em&gt;B&lt;/em&gt;-bit hash of Alice's
password. It takes Mallory about &lt;em&gt;2^B&lt;/em&gt; guesses to find a preimage. But since
&lt;em&gt;B = H(P) - lg(t)&lt;/em&gt;, Mallory will find about &lt;em&gt;t&lt;/em&gt; collisions when she performs
the same search she would if it was instead a 256-bit hash (this is not at
all a formal argument, but hopefully you see the idea behind it).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;By supposition, Mallory has rooted System &lt;em&gt;X&lt;/em&gt;, so there is no point trying to
secure Alice's account on &lt;em&gt;X&lt;/em&gt; anymore. All that remains is the security of
Alice's account on system &lt;em&gt;Y&lt;/em&gt;. This breaks down if Mallory can get read-only
access to the hash database without rooting... but suppose the root password is
stored in plain text in the hash database ;) .&lt;/p&gt;
&lt;p&gt;Because System &lt;em&gt;Y&lt;/em&gt; is using different salts, it is unlikely that any of the &lt;em&gt;t&lt;/em&gt;
collisions Mallory found, except &lt;em&gt;P&lt;/em&gt; itself, can be used to authenticate as
Alice to System &lt;em&gt;Y&lt;/em&gt; (reader: double check this). So Mallory's best option is to
try authenticating to System &lt;em&gt;Y&lt;/em&gt; as Alice using the &lt;em&gt;t&lt;/em&gt; collisions as passwords
guesses, since she knows &lt;em&gt;P&lt;/em&gt; is one of those &lt;em&gt;t&lt;/em&gt; collisions, and by construction
&lt;em&gt;lg(t) &amp;lt; H(P)&lt;/em&gt;. This will take &lt;em&gt;t * t&lt;/em&gt; time, for an effective security of &lt;em&gt;2
* lg(t)&lt;/em&gt; bits.&lt;/p&gt;
&lt;p&gt;If, instead, System &lt;em&gt;X&lt;/em&gt; was using standard 256-bit hashes, Mallory would have
found the exact &lt;em&gt;P&lt;/em&gt; and could get into System &lt;em&gt;Y&lt;/em&gt; on the first try. Using this
scheme it takes about &lt;em&gt;t&lt;/em&gt; tries. So by weakening the hash, Alice's account on
System &lt;em&gt;Y&lt;/em&gt; is more secure than it would have been had the hash not been
weakened.&lt;/p&gt;
&lt;p&gt;Of course, this system is impractical, since it assumes knowledge of how Mallory
would guess &lt;em&gt;P&lt;/em&gt;, and thus the entropy of &lt;em&gt;P&lt;/em&gt;. It also assumes that if Alice's
hash on System &lt;em&gt;X&lt;/em&gt; gets compromised, then the security of her account on &lt;em&gt;X&lt;/em&gt; no
longer matters at all, which is obviously not always the case. It is
nevertheless interesting to see how the altruism of the compromised system can
increase the security of Alice's account on the other system.&lt;/p&gt;
&lt;p&gt;Another problem is that the user must wait &lt;em&gt;t&lt;/em&gt; units of time when logging in, so
in practice there would be tradeoff between security and log-in wait time.
Locking the accounts after significantly less than &lt;em&gt;t&lt;/em&gt; attempts might be
a better approach.&lt;/p&gt;
&lt;p&gt;It doesn't look like it can be made any better than this, since if you decrease
B any further, finding collisions with an online attack becomes easier than
guessing P, but it is still an online (thus detectable, stoppable) attack so it
might still be harder. I would guess that the wait time &lt;em&gt;t&lt;/em&gt; would be better
spent computing iterations of PBKDF2 or similar.&lt;/p&gt;
</summary><category term="passwords"></category><category term="hashing"></category></entry><entry><title>The Machine that Alters Votes (2012 USA Election)</title><link href="/blog/the-machine-that-alters-votes-2012-usa-election.html" rel="alternate"></link><updated>2012-11-06T00:00:00-07:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-11-06:the-machine-that-alters-votes-2012-usa-election.html</id><summary type="html">&lt;p&gt;So there's &lt;a class="reference external" href="https://www.youtube.com/watch?v=QdpGd74DrBM"&gt;this video&lt;/a&gt; of a voting machine that selects Romney when you try to
click on Obama.&lt;/p&gt;
&lt;p&gt;To someone who has had some experience with touch screen technology, it looks
like the touch system is just out of sync with the UI, which could be fixed by
re-calibrating the system. According to the uploader, it is not a calibration
issue, because they tried tapping other names and they all worked fine. You can
find the uploader's comments in the description of the video. I have no reason
to doubt the uploader's sincerity, since &lt;a class="reference external" href="http://www.motherjones.com/mojo/2012/11/romney-loving-voting-machine-recalibrated-and-back-online"&gt;according to Mother Jones&lt;/a&gt; the
machine was actually taken out of service and &amp;quot;recalibrated.&amp;quot; So the video is
(probably) not fake.&lt;/p&gt;
&lt;p&gt;A lot of people are now assuming this was done intentionally to steal votes from
Obama in favor of Romney. The mainstream media is picking up on the story as
well. The problem with this belief is that if someone did intentionally make the
voting machine behave this way, they could have done something far worse. They
could have made the system swap the votes invisibly, behind-the-scenes, so that
nobody ever notices.&lt;/p&gt;
&lt;p&gt;If it was done intentionally, and whoever did it could have made the machine
swap votes invisibly, then you have to ask the question: Why did they make it
visible? Certainly if a &lt;em&gt;lot&lt;/em&gt; of these machines started doing what is seen in
the video, a lot of people would notice, and it would be clear that there was
some kind of fraud was going on. The election results would clearly be invalid.
A lot of vote-altering machines would invalidate the election, but just one is
enough to make everyone panic and to get the story covered by the popular news
media, giving Romney some potentially bad publicity. So a possibly better
explanation, if it was intentional, is that it was done by a supporter of one of
the &lt;em&gt;other&lt;/em&gt; candidates.&lt;/p&gt;
&lt;p&gt;Or, it could just be a bug. I think it is.&lt;/p&gt;
</summary><category term="voting"></category></entry><entry><title>Coders, PLEASE STOP inventing your own hash functions!</title><link href="/blog/coders-please-stop-inventing-your-own-hash-functions.html" rel="alternate"></link><updated>2012-08-21T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-08-21:coders-please-stop-inventing-your-own-hash-functions.html</id><summary type="html">&lt;p&gt;Today, I came across an &lt;a class="reference external" href="&amp;quot;http://arstechnica.com/security/2012/08/passwords-under-assault/"&gt;article on password cracking&lt;/a&gt;. In the comment section
I saw someone had posted (presumably right after they just read about salting)
the following reply:&lt;/p&gt;
&lt;pre class="code text literal-block"&gt;
My solution: don't store hashes as a single SHA1 or MD5 result ...
combine it for further obfuscation. A hash is designed to fall into
enemy hands, so don't make it easy to produce rainbow tables.

SAMPLE - All other password weaknesses still apply!

function generateHash($name, $pass)
{
$salt = '';
for($i = 0; $i &amp;lt; strlen($name); $i++) { $salt = $i . $salt . $name . $i; }
return (sha1($salt . $pass) . sha1($pass . $name . $salt));
}
&lt;/pre&gt;
&lt;p&gt;This code is exactly as secure as &lt;tt class="docutils literal"&gt;sha1( $name . $pass );&lt;/tt&gt;. It does not make
it harder to produce rainbow tables, it is &lt;a class="reference external" href="https://defuse.ca/blog/2012/06/what-is-security-through-obscurity/"&gt;security through obscurity&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I come across an example like this almost ever week. Please stop inventing your
own hash functions and use a &lt;a class="reference external" href="https://crackstation.net/hashing-security.htm"&gt;standard salted and iterated key derivation
function&lt;/a&gt;.&lt;/p&gt;
</summary><category term="passwords"></category><category term="hashing"></category></entry><entry><title>Recovering CBC-mode IV via Chosen Ciphertext</title><link href="/blog/recovering-cbc-mode-iv-chosen-ciphertext.html" rel="alternate"></link><updated>2012-08-12T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-08-12:recovering-cbc-mode-iv-chosen-ciphertext.html</id><summary type="html">&lt;p&gt;Suppose a system uses a constant internal initialization vector to
encrypt/decrypt data in CBC mode, and you'd like to know what it is. If you can
make the system decrypt chosen ciphertexts, this is how you do it:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Make the system decrypt two equal blocks of ciphertext (e.g. all zeroes).&lt;/li&gt;
&lt;li&gt;XOR the two resulting blocks of &amp;quot;plaintext&amp;quot; together.&lt;/li&gt;
&lt;li&gt;XOR that with the original ciphertext block.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Visually:&lt;/p&gt;
&lt;img alt="Recovering IV with chosen ciphertext" src="https://defuse.ca/images/iv-recovery.gif" /&gt;
&lt;p&gt;The best I can think of for recovering a static IV under chosen plaintext is
a meet-in-the-middle attack as follows.&lt;/p&gt;
&lt;p&gt;Observation 1: We can specify input directly to the cipher by:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Encrypt a one-block plaintext X, getting the resulting ciphertext C.&lt;/li&gt;
&lt;li&gt;Encrypt the two-block plaintext X||(Y xor C), where Y is the block we want to
feed directly into the cipher.&lt;/li&gt;
&lt;li&gt;The second block of ciphertext will be the result of feeding Y directly into
the cipher.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Observation 2: We can encrypt the IV itself and variations of it by varying the
first block of plaintext. Formally C = E(V xor IV), when V is the first block of
plaintext. We'll call V a &amp;quot;variation vector.&amp;quot;&lt;/p&gt;
&lt;p&gt;So,&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Create a lookup table mapping 2^64 (assuming the block size is 128 bits)
random variation vectors &lt;em&gt;from&lt;/em&gt; the resulting ciphertext. This lets us look
up what variation we made to the IV to result in a given ciphertext block.&lt;/li&gt;
&lt;li&gt;Use the method in observation 1 to encrypt random blocks fed directly into
the cipher. Look up each ciphertext in the table from step (1). If it's
there, then the IV is &amp;lt;the block that was fed directly into the cipher&amp;gt; XOR
&amp;lt;the variation vector&amp;gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The lookup table from step (1) gives us a 1 in 2^64 chance of finding the IV per
known plaintext-ciphertext pair. So it should take about 2^64 iterations in step
(2) before we recover the IV.&lt;/p&gt;
</summary><category term="cryptography"></category></entry><entry><title>Escaping String Literals (for JavaScript) in PHP</title><link href="/blog/escaping-string-literals-for-javascript-in-php.html" rel="alternate"></link><updated>2012-07-01T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-07-01:escaping-string-literals-for-javascript-in-php.html</id><summary type="html">&lt;p&gt;Use the following code to escape user-supplied input before inserting it into
a JavaScript string literal.&lt;/p&gt;
&lt;pre class="code php literal-block"&gt;
&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;js_string_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;$safe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ctype_alnum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
            &lt;span class="nv"&gt;$safe&lt;/span&gt; &lt;span class="o"&gt;.=&lt;/span&gt; &lt;span class="nv"&gt;$data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="nv"&gt;$safe&lt;/span&gt; &lt;span class="o"&gt;.=&lt;/span&gt; &lt;span class="nb"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s2"&gt;x%02X&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;]));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$safe&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="code php literal-block"&gt;
&lt;span class="x"&gt;&amp;lt;script&amp;gt;
var foo = &amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt; &lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="nx"&gt;js_string_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$bar&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;;
&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The standard htmlentities and htmlspecialchars functions don't work because
JavaScript will interpret the HTML entities as a part of the literal string (not
decode them). addslashes is insufficient because it does not escape other
special characters that might convince some browsers that the string literal or
script section has ended (for example, the string &amp;quot;]]&amp;gt;&amp;quot; to end a &lt;a class="reference external" href="http://www.w3schools.com/xml/xml_cdata.asp"&gt;CDATA&lt;/a&gt;). To
escape integers and floats, use these:&lt;/p&gt;
&lt;pre class="code php literal-block"&gt;
&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class="c1"&gt;// returns &amp;quot;0&amp;quot; when given something that isn't an integer.
&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;js_integer_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;$cast&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$cast&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$cast&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code php literal-block"&gt;
&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class="c1"&gt;// returns &amp;quot;0&amp;quot; when given something that isn't a float
&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;js_float_escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nb"&gt;is_float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nb"&gt;is_numeric&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nx"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
</summary><category term="javascript"></category><category term="escaping"></category></entry><entry><title>Cracking eHarmony's Unsalted Hashes with CrackStation</title><link href="/blog/cracking-eharmonys-unsalted-hashes-with-crackstation.html" rel="alternate"></link><updated>2012-06-09T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-06-09:cracking-eharmonys-unsalted-hashes-with-crackstation.html</id><summary type="html">&lt;p&gt;This week, LinkedIn, eHarmony, and last.fm have all confirmed that their
password hash databases have been breached. In all three cases, passwords were
stored as an unsalted hash. I've already reported the &lt;a class="reference external" href="https://defuse.ca/blog/2012/06/cracking-linkedin-hashes-with-crackstation/"&gt;results of cracking
LinkedIn's password hashes with CrackStation&lt;/a&gt;, now it's eHarmony's turn.&lt;/p&gt;
&lt;p&gt;eHarmony stored their users' passwords as an unsalted md5 hash. The leaked file
contains 1,516,877 hashes. You can download the original file from one of either
of the following links:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://defuse.ca/files/eharmony-hashes.txt"&gt;eHarmony Hashes HTTP Mirror&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://thepiratebay.se/torrent/7341755/eHarmony_Unsalted_MD5_Hash_Database"&gt;eHarmony Hashes TORRENT Mirror&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are no repeated hashes in the file, so presumably the party that leaked
them removed the duplicates. Because there are no duplicates, I can't provide
any &amp;quot;most common passwords&amp;quot; statistics, but I can report how many
&lt;a class="reference external" href="https://crackstation.net/"&gt;CrackStation&lt;/a&gt; was able to crack, and how fast it did so.&lt;/p&gt;
&lt;p&gt;The cracking process took 23.47 hours and recovered 275,860 (18.2%) of the
passwords. CrackStation processed the hashes at an average rate of 17.94 hashes
per second. All passwords are upper case, so I suspect that eHarmony was
converting passwords to upper case before hashing them to implement case
insensitivity (another big no-no).&lt;/p&gt;
&lt;p&gt;CrackStation uses two dictionaries. One, which I call the &amp;quot;medium&amp;quot; dictionary,
has 1,493,677,782 entries. The other, which I call the &amp;quot;huge&amp;quot; dictionary, has
15,171,326,912 entries. 250,122 of the cracked passwords are present in the
&amp;quot;medium&amp;quot; dictionary, 97,419 are in the &amp;quot;huge&amp;quot; dictionary, and 71,380 passwords
are in both.&lt;/p&gt;
&lt;p&gt;If eHarmony had &lt;a class="reference external" href="https://crackstation.net/hashing-security.htm"&gt;used salt in their hashes&lt;/a&gt; like they should have been,
I wouldn't have been able to run this attack. In fact, salting would have forced
me to run a dictionary attack on each hash by itself, and that would have taken
me over 31 years.&lt;/p&gt;
&lt;p&gt;I'm very glad the LinkedIn, eHarmony, and last.fm breaches all went public at
nearly the same time. The stories are have been covered by nearly every tech
news website, and the issue of inadequate server-side password protection is
finally being addressed. I hope other companies will learn from these breaches
and start using salted hashes if they aren't already doing so.&lt;/p&gt;
&lt;p&gt;Unsalted hashes are bad, but storing passwords in plain-text is even worse.
Visit my &lt;a class="reference external" href="https://defuse.ca/password-policy-hall-of-shame.htm"&gt;Password Policy Hall of Shame&lt;/a&gt; for a list of websites that are
probably storing your password in the clear.&lt;/p&gt;
&lt;p&gt;You probably came here wanting to see passwords, so I won't disappoint. Here's
a random sample:&lt;/p&gt;
&lt;pre class="code text literal-block"&gt;
39007e310acd5cc5582c34c408ebf4cc :: RAWANN
c69f24b431852eb5b2db419860387dad :: SHELDURAY88
713f6fcbeeacbd3a78401382f88f5d1f :: KJ1017
86fc184cabcf0626c479927cc4e5e998 :: PUSSY310
c075be959b6831fb01d52591963d12b7 :: KARAAGE4
6c058fea843d5bff058c939fde3a6eb8 :: TH3EMPRESS
2dfecece2bf00698dd5fbae90e2f0860 :: ELLEGRA
e720578393bb68956f079c3db426d6ec :: 81PIRTER73
b0963f1a7fd94698a6e76e402daffcef :: KORRESHI
026d29ad37c6c672315e5a9c358d0a7c :: CLC47
7d01d8893e7ddbb18ceb40c59ef384c2 :: ROMELP
bf1a688689f82ba39b9efa236d09c539 :: OFTROY
dfcd9ad16c5358c1c420343a7b2b683b :: MVN2006
14f6609d95e3830b14709bce165041af :: MIKYONE
2b1841891df6de05b163d8dbbe79036c :: JAMFILE
9fe44d8eb7fbc5217fad2e54d09871ed :: TRIATA
961887ee6a084c02619f22f6b2e8a852 :: IAMTHATIS
fd9d9fa433c0d9385345355c17be13f4 :: PEACHKA1
fa22376fe0782fe9313385846e66b979 :: JAHAAD
095614e5971ad8a81d4f232c00bbf33d :: SARAHMIA1
f14c92dd1b2281cdf0f5999e595442de :: LEBIN
6e0f9ff4606b41705ea25bcbff1ac94b :: WINGK2
49cacc76a288058b68ded69f0c804269 :: CHARLIEXX
cbc7f37615111efe8e246d3316e24408 :: MB1229
81fc99cc34d28eec3c90109cab7ddfbe :: EMETI
e838f7db8ef56faa9b49e8215dfbbee7 :: KITABLAR
02ae65a2f3dac98a54290f09c39758ed :: JENGARY
3a7edcb86afee6b0853fba0a16672bcd :: GODSPELL2
22d541659b917e40146f4d4256b2a2e2 :: LETSTALK2
4e953e9a0a0f2503e8b8269b2c4a8057 :: 1MEMO1
&lt;/pre&gt;
</summary><category term="passwords"></category><category term="hashing"></category><category term="eharmony"></category></entry><entry><title>Cracking LinkedIn's Hashes with Crackstation</title><link href="/blog/cracking-linkedin-hashes-with-crackstation.html" rel="alternate"></link><updated>2012-06-08T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-06-08:cracking-linkedin-hashes-with-crackstation.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://linkedin.com/"&gt;LinkedIn&lt;/a&gt;'s user database has been &lt;a class="reference external" href="https://news.ycombinator.com/item?id=4073309"&gt;breached&lt;/a&gt;. The passwords were hashed with
SHA1, but salt was not used. 6 million of them have been published to the
internet. You can download them via &lt;a class="reference external" href="http://thepiratebay.se/torrent/7334648/LinkedIn_Password_Hashes"&gt;torrent&lt;/a&gt; or via HTTP from &lt;a class="reference external" href="http://defuse.ca/files/linkedin-sha1.txt"&gt;defuse.ca's
mirror&lt;/a&gt;. 3.5 million of them have had their first 5 hex digits replaced with
zero -- some suspect this was used as a way to mark which have been cracked by
another party &lt;a class="reference external" href="https://news.ycombinator.com/item?id=4073928"&gt;(source)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A bit of googling reveals that LinkedIn has about 120 million registered
accounts, so the 6,143,150 hashes represent about 5% of LinkedIn users
Correction: Since duplicates were removed from the hash list, it must represent
a much larger portion of LinkedIn users. Since passwords are so often re-used,
I wouldn't be surprised if it was the entire database. 3,521,180 have been
cracked by an unknown third party. That leaves 2,621,970 for me to try to crack
with &lt;a class="reference external" href="https://crackstation.net/"&gt;CrackStation&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="what-is-crackstation"&gt;
&lt;h2&gt;What is CrackStation?&lt;/h2&gt;
&lt;p&gt;CrackStation is basically a giant lookup table -- a sorted list of hashes,
mapped to their corresponding plaintext. To crack a hash, all I have to do is
run a binary search through the hash index file to get the location of the
plaintext in the wordlist file. This process is very efficient; a 200GB index
file (15 billion hashes) can be searched in only a fraction of a second, even on
a standard 7200rpm hard disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="crackstation-results"&gt;
&lt;h2&gt;CrackStation Results&lt;/h2&gt;
&lt;p&gt;It took 31.8 hours to process all 2,621,970 not-yet-cracked hashes. That's an
average of 22 hashes processed per second. In the end, I was able to crack
31,831 hashes -- about 1.2%. CrackStation's &amp;quot;medium&amp;quot; dictionary, which has
1,493,677,782 entries, cracked 23,529 (0.8%) of them. The &amp;quot;huge&amp;quot; dictionary,
which has 15,171,326,912 cracked 10034 (0.3%) of them. These figures are not
exclusive -- 1732 hashes were cracked by both dictionaries (I did not optimize).&lt;/p&gt;
&lt;p&gt;Duplicates were removed from the original list of hashes, so I cannot provide
&amp;quot;most common passwords&amp;quot; statistics. Here's a random sample of what I cracked (I
will not be releasing the full list):&lt;/p&gt;
&lt;pre class="code text literal-block"&gt;
6764dcf2d9c84b9d66fd5c8a78691affde1045e1 :: sangeetalahiri
d6b3ebab49bd83a60de4f5b84d9fe61eff5cba73 :: DualPhone
c79b146f16d3442bb2adb00cf9a6e456aacdb877 :: juan.rondon
777bb3743c7424b477ae95f0b002cffc3a6d8f57 :: Charlcombe1
a567e183044b8a881a8aec41387614f7963b60be :: hydroworx1
7f97cd544c2937e494265a6a5a4ae3edf6a391e8 :: Jetravaille
87f11d9ccda89e463cf92e3f84dbf1f5b9b5f84a :: Nangiya1
1168caf06e26fb82642b069dc306b9a849e9448f :: kab&amp;#64;las
3722fd3f3cded4dc1231df6b16190364eaf71184 :: grasmachien
5a61c766bb6ea7294a6a0e6e2ccbda8c4eed0ebc :: Eidner4
&lt;/pre&gt;
&lt;p&gt;These results aren't really meaningful, since I only tried to crack the set of
hashes that were not already cracked by someone else, but it was a fun exercise
to test the strength of CrackStation's password dictionaries. It is also a great
demonstration of why salt is &lt;strong&gt;crucial&lt;/strong&gt; to password security. If we assume that
all of the previously-cracked hashes could have been cracked by CrackStation,
then I would have been able to crack 3,553,011 (57.8%) in only 78 hours, or 19
hours if cracked them in parallel on a quad-disk quad-core system. That figure
is consistent with other bulk cracking jobs CrackStation has done in the past.&lt;/p&gt;
&lt;p&gt;The reason I cannot crack the ones that had their first 5 hex digits set to
00000 is because CrackStation's indexes are sorted on the first 48 bits of the
hash, with the first bits being the most significant. Without all of those bits,
I can't do a binary search through the index file. I could rebuild the index
using the last 48 bits of the hash, but that would take days and hundreds of
gigabytes of hard drive space. I don't want LinkedIn users' passwords that bad.
If there is significant public interest in the results, then I will consider
doing it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This kind of attack wouldn't work if the hashes were salted. If they were
salted, I'd have to run a dictionary attack on each hash individually, which can
take upwards of an hour per hash for a similar-quality attack. So if you run
a website that stores user passwords, please make sure they are &lt;a class="reference external" href="https://crackstation.net/hashing-security.htm"&gt;hashed with
salt&lt;/a&gt;. If they aren't, (LinkedIn, are you listening?), then you are an
irresponsible webmaster.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="passwords"></category><category term="hashing"></category><category term="linkedin"></category></entry><entry><title>What is Security Through Obscurity</title><link href="/blog/what-is-security-through-obscurity.html" rel="alternate"></link><updated>2012-06-04T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-06-04:what-is-security-through-obscurity.html</id><summary type="html">&lt;p&gt;Today a member of &lt;a class="reference external" href="https://www.grc.com/discussions.htm"&gt;GRC's Newsgroups&lt;/a&gt; posed a question about security through
obscurity:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It seems to me that ALL digital security is EXACTLY &amp;quot;security through
obscurity&amp;quot;. Take, for example, AES... It isn't that the possible range of
keys is unknown, it is just a cleverly hidden needle in an enormously HUGE
haystack.  It could actually be possible to arrive at the correct key on the
first guess.  However, I wouldn't bet anything you care about on that, since
it would be about as likely as me saying, &amp;quot;I'm thinking of a particular atom
somewhere in the universe. Can you guess which one?&amp;quot; Nevertheless, in set
notation, it would be trivial to describe the set which includes the correct
key. It is simply obscured by all the wrong keys.&lt;/p&gt;
&lt;p&gt;So, by your definition, what is &lt;em&gt;real&lt;/em&gt; security?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It's a very interesting question, and it made me realize that in all of the
research I've done on cryptography, I've never seen a formal definition of
security through obscurity. It took me a while to come up with a reasonable
response (something other than &amp;quot;I know it when I see it.&amp;quot;). My first thought was
anything that doesn't follow &lt;cite&gt;Kerckhoffs's principle&lt;/cite&gt; is security through
obscurity, but I wanted something more general. After a bit more thinking,
I decided that measurability is the main distinction between something that
isn't security through obscurity, and something that is. Here's what I wrote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Informally, I would define security, with respect to cryptography, as
something that requires a well-defined and measurable amount of resources to
break in a specific scenario.&lt;/p&gt;
&lt;p&gt;For example, if a message is encrypted in AES-256 in CBC mode, with a random
key, and the adversary knows the plaintext is english, but doesn't know
anything about the key, then the security factor is 2^256 i.e. the adversary
has to do on average 2^255 operations to successfully decrypt the
ciphertext.&lt;/p&gt;
&lt;p&gt;Note that this means that even if the key is just one bit, it is still
&amp;quot;real&amp;quot; security, as long as the adversary knows that the key is either &amp;quot;1&amp;quot;
or &amp;quot;0&amp;quot;. It is very weak security, but the difficulty of cracking it is still
well-defined and computable.&lt;/p&gt;
&lt;p&gt;Security though obscurity is anything that doesn't have a well-defined and
computable &amp;quot;security factor&amp;quot; in at least one scenario.&lt;/p&gt;
&lt;p&gt;For example, if you are trying to smuggle pirated software across the U.S.
border, you may choose to encode the data into the least significant bits of
the RGB values in an image file. There is software for doing (and un-doing)
this, so it would not be hard for the border patrol officer to extract the
data, if he knew it was there. Your security rests on whether or not the
officer will know to look in the least significant bits for hidden data.
This is not well-defined and cannot be computed into a &amp;quot;security factor&amp;quot;
like above.&lt;/p&gt;
&lt;p&gt;A real-world example is if you just won the lottery and you are looking for
a place to hide your money (supposing banks don't exist):&lt;/p&gt;
&lt;p&gt;You could choose to buy a safe, rated to withstand 60 minutes of attack with
blow torches. This is &amp;quot;real&amp;quot; security, the amount of work an adversary has
to do to break into the safe is well-defined and computable.&lt;/p&gt;
&lt;p&gt;You could also choose to hide your money inside the door of your car
(between the interior panel and the exterior metal). It would not be at all
difficult for an adversary to steal your money, if they knew it was there.
The security provided by &amp;quot;Will the adversary ever think that I am hiding the
money in the door of my car?&amp;quot; is not well-defined nor computable, so this is
security through obscurity.&lt;/p&gt;
&lt;p&gt;This is just my opinion on the matter. Cryptography texts and/or experienced
cryptographers may disagree.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This definition can be applied to the idea of trying to keep an encryption
algorithm secret. If the security of the algorithm depends on it's secrecy, then
it is security through obscurity, because the amount of work an adversary (who
can run chosen plaintext and chosen ciphertext attacks) has to do to reverse
engineer the algorithm is not well-defined and cannot be computed.&lt;/p&gt;
</summary><category term="obscurity"></category></entry><entry><title>The Economics of Password Cracking</title><link href="/blog/the-economics-of-password-cracking.html" rel="alternate"></link><updated>2012-05-05T00:00:00-06:00</updated><author><name>Taylor Hornby</name></author><id>tag:/blog,2012-05-05:the-economics-of-password-cracking.html</id><summary type="html">&lt;p&gt;We know that it's possible to come up with a password that no computer on earth
can crack. Use true random data to generate a sequence of 20 characters from the
full ASCII printable set, spend an hour memorizing, and you're good. We also
know that most people don't do that. What we don't know (or at least often
forget) is that people don't need to do that.&lt;/p&gt;
&lt;p&gt;We estimate our password strength by the amount of time it would take the
fastest imaginable supercomputer to search through the set of all passwords of
equal or less length and find ours. What we often forget is that the bad guys
don't have those kinds of resources, and they rarely ever crack passwords via
brute-force search.&lt;/p&gt;
&lt;p&gt;Why not? Because most bad guys won't build a billion-dollar supercomputer to
crack one password, and most people with billion-dollar supercomputers aren't
willing to rent out their processing power for password cracking. It isn't
profitable, and those supercomputers can be used for better things like
scientific research.&lt;/p&gt;
&lt;p&gt;The Bitcoin network is currently computing 11.74 trillion sha256 hashes per
second (&lt;a class="reference external" href="http://bitcoinwatch.com/"&gt;see here for current stats&lt;/a&gt;). The network will compute &lt;tt class="docutils literal"&gt;3.702x10^20&lt;/tt&gt;
hashes in one year if it continues at it the same rate (my guess is that it will
grow, but it's already over 10 times as powerful as &lt;cite&gt;the fastest known
supercomputer&lt;/cite&gt;).  That may seem like a lot of hashes, but if you do the math,
you'll see that its not even enough to do a brute-force search through the set
of all 11-character ASCII passwords. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;log(3.702x1020)/log(95)&lt;/span&gt; = 10.40&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;Read it again: &lt;strong&gt;The Bitcoin network is made up of millions of dollars worth of
hardware and is 10x faster than the fastest known supercomputer, but it can not
brute-force guess an 11-character password in a year.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There is no business model that makes brute-force password cracking profitable.
To see why, consider the following argument:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;If the password can't be cracked with good quality dictionaries or rainbow
tables, it is long and complex.&lt;/li&gt;
&lt;li&gt;Since the fastest distributed computing network on earth can barely search
through the set of all 10-character ASCII passwords in a year, the
probability of cracking a long and complex password via brute-force search in
a reasonable amount of time is low.&lt;/li&gt;
&lt;li&gt;Since the probability of successfully cracking a password via brute-force is
low, to make any money, you must charge the customer even if you cannot crack
it.&lt;/li&gt;
&lt;li&gt;Since the probability of successfully cracking a password via brute-force is
low, and the customer must pay even if you cannot crack it, the customer will
not be willing to pay very much.&lt;/li&gt;
&lt;li&gt;A decent brute-force attack requires a lot of time on an expensive
supercomputer, so you must charge a lot.&lt;/li&gt;
&lt;li&gt;(4) and (5) are incompatible with each other, so it is impossible to run
a profitable brute-force cracking business.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course (4) may not hold true when the customer is a government and the
password is the key to winning a war, but most passwords don't have that much
value.&lt;/p&gt;
&lt;p&gt;What this tells us is that we don't need to worry about brute-force attacks.
They always succeed (by definition), but rarely in a reasonable amount of time
and there is rarely ever a password valuable enough to justify one.&lt;/p&gt;
&lt;p&gt;So ironically, the most profitable kind of password cracking requires very
little computational resources (a single 6-core system satisfies
&lt;a class="reference external" href="https://crackstation.net/"&gt;crackstation.net&lt;/a&gt;'s needs). The key to being profitable in the password
cracking industry is to be clever and do as much as you can without
a supercomputer. That means implementing extremely fast look-up tables and
constructing extremely effective dictionaries -- going after the low-hanging
fruit.&lt;/p&gt;
&lt;p&gt;That's exactly what the bad guys do, and that's exactly what my hash cracking
service does. If you want your password to be secure, don't worry about
comparing its strength to a hypothetical supercomputer, just make sure it's not
a low-hanging fruit, and make brute-force search the only option for your
adversary. Then they probably won't even bother trying.&lt;/p&gt;
&lt;p&gt;The easiest way to get out of the low-hanging fruit zone is to make your
password long. Take a look at &lt;a class="reference external" href="https://www.grc.com/haystack.htm"&gt;GRC's Password Haystacks&lt;/a&gt; page for some good
advice.&lt;/p&gt;
&lt;p&gt;Here's a tip: My hash cracking service is backed by the largest known password
cracking dictionary, which has just over 15 billion entries. There are over
7 billion possible 5-character ASCII strings. So if you include 5 random ASCII
characters in your password and pad it out to at least 12 characters with
something memorable (not a word!), you can be pretty sure that your password
isn't a low-hanging fruit.&lt;/p&gt;
</summary><category term="passwords"></category><category term="hashing"></category><category term="cracking"></category></entry></feed>