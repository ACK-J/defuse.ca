Behind the Screens
By Steve Gibson
InfoWorld Sep 29, 1986

Interpreters and Compilers: Two Approaches to the Arcane Language of Computers

We know that computers deal exclusively in the somewhat arcane realm of binary arithmetic and opaque machine language, with nothing but 1s and 0s for company. Two fundamental approaches have developed that allow nonbinary humans to express their needs to these algorithmic enigmas: language compilers and interpreters.

Source code is the universal term for the "stuff" that we write for computer digestion. While none of it looks like anything we'd term "language," it is in fact a language resulting from a compromise between the computer's needs and our needs.

With the program's source code written, we're ready for the computer to produce the results. Here the machine makes a choice: The computer can either interpret the meaning of the source code step-by-step as it performs the actual work of the program, or it can first compile the meaning of the entire program into its own arcane machine language (known as object code) and then execute this new program. This is the distinction between interpreters and compilers.

Looking at it another way, the total job for the computer consists of two parts: determining what we want done, and then doing it. A compiler completes the job of determination before beginning to do any of the program's work, whereas an interpreter keeps it mixed, determining what we want step by step as it is done.

From this understanding, we can see why different niches have evolved for interpreters and compilers. Compilers once had the whole industry to themselves. Then the popular Basic language was created. Being interpreted, Basic did not require a "compile phase." A program could be run immediately after being entered. What's more, the interpreter made many "semantic" checks as each line of the program was being entered, catching many "typos." The interpreted progam could also be easily interrupted, allowing users to "look inside" and examine the state of things.

This high level of interactivity, the ability to edit the progra, give it a try, interrupt it to see what's going on, and then edit and try again, has created a firm foundation for modern interpreters.

But interpreters are not the end-all answer. Since they mix determination of the task with its execution, they're forever bound to operate more slowly than the code produced by a compiler - where execution is completely separated from the task of determination. An interpreted program is also inherently less secure, since the original source code is always around being interpreted and could be "borrowed" by unscrupulous competitors. Finally, while the unique "write it, run it, and edit it" cycle afforded by interpreters makes a lot of sense during the development of a program, it doesn't make nearly as much sense after the program has been completed. This is the time to bring out the compiler, ltting it take all the time it wants, producing a compact, superfast executing program.

There are now Basic compilers that boast source code compatibility with the popular Basic interpreters. This means that exactly the same source code that was being happily interpreted during development can then be compiled without change for repeated maximum performance use.

Interactive-mode development can be so effective, in fact, that interpreters have been developed for successful compilers. The popular compiled C language has recently acquired a bevy of source code compatible interpreters to support an interactive development phase of large C language projects.

the concept of "letting the computer take all the time it wants" to perform the translation of the program from the original source code into the computer's own superfast object code is important. In the future you'll hear more and more talk of optimizing compilers, which take multiple passes through the work they've done looking for clever ways to make the final output faster and/or smaller.

I'll leave you with an annoying "chicken and egg" puzzle to ponder. There are several very successful programming environments, such as UCSD Pascal, Forth, and Smalltalk, that were actually written in the languages themselves! The problem is that after writing all of the source code for the language's implementation of itself, you couldn't run it unless you already had the language running. I think I'm going to go have a chat with a chicken.
