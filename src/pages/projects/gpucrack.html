<h1>Salted MD5 Cracking with CUDA (NVIDIA Graphics Cards)</h1>
<p>This is the only open source code that I know of that can brute force an MD5 hash with salt. It allows you to specify left salt and right salt. In the example below, I crack the hash of "http://ossbox.com" using "http://" as the left salt and ".com" as the right salt. You will need the Nvidia CUDA SDK (nvcc) to compile this code. You must also have an Nvidia 8800GT or higher to run the code. If the code doesn't run on your graphics card, try changing the THREADS_PER_BLOCK and BLOCKS constants to lower values.</p>

<p><a href="source/gpu_salted_brute_example.tar.gz"><b>Download the Source Code</b></a></p>
<h2>Benchmarks</h2>
<p>No attempt has been made to optimize the kernel code or the constants, but here are some early benchmarks:</p>
<table border="1" >
<tr><th>GPU</th><th>Parameters</th><th>Speed (md5 per second)</th></tr>
<tr><td>260M</td><td>Default (see source)</td><td>60M</td></tr>
<tr><td>8800GT</td><td>'aaazzzzzzzbbb' with 'aaa' as left salt and 'bbb' as right salt. Default constants.</td><td>80M</td></tr>
<tr><td>8800GT</td><td>'zzzzzzz' with no salts. Default constants.</td><td>100M</td></tr>
</table>
<h2>Output</h2>
<div style="font-family: monospace;"><ol><li><div class="div0">&nbsp;[xx@xx xx]$ nvcc main.cu ; ./a.out 
</div></li><li><div class="div1">&nbsp;STATUS: krfpda
</div></li><li><div class="div0">&nbsp;STATUS: cbphxc
</div></li><li><div class="div1">&nbsp;STATUS: ukyzqf
</div></li><li><div class="div0">&nbsp;STATUS: muhski
</div></li><li><div class="div1">&nbsp;STATUS: eerkel
</div></li><li><div class="div0">&nbsp;STATUS: wnadyn
</div></li><li><div class="div1">&nbsp;STATUS: oxjvrq
</div></li><li><div class="div0">&nbsp;STATUS: ghtnlt
</div></li><li><div class="div1">&nbsp;STATUS: yqcgfw
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;FOUND: http://ossbox.com
</div></li><li><div class="div1">&nbsp;</div></li></ol></div>
<h2>main.cu</h2>
<div style="font-family: monospace;"><ol><li><div class="div0">&nbsp;//Salted MD5 brute force with CUDA
</div></li><li><div class="div1">&nbsp;//By FireXware, Aug 2nd 2010.
</div></li><li><div class="div0">&nbsp;//OSSBox.com
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;//TODO: rename variables so they are called length, not max, max means max size, length means length including null terimnation
</div></li><li><div class="div1">&nbsp;//TODO: optimize
</div></li><li><div class="div0">&nbsp;//TODO: get command line arguments
</div></li><li><div class="div1">&nbsp;//TODO: md5 2nd block
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;#define MAX_BRUTE_LENGTH 14 
</div></li><li><div class="div0">&nbsp;#define MAX_SALT_LENGTH 38
</div></li><li><div class="div1">&nbsp;#define MAX_TOTAL (MAX_SALT_LENGTH + MAX_BRUTE_LENGTH + MAX_SALT_LENGTH)
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;//Performance:
</div></li><li><div class="div0">&nbsp;#define BLOCKS 64
</div></li><li><div class="div1">&nbsp;#define THREADS_PER_BLOCK 128

</div></li><li><div class="div0">&nbsp;#define MD5_PER_KERNEL 200
</div></li><li><div class="div1">&nbsp;#define OUTPUT_INTERVAL 20
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;__device__ __constant__ unsigned char cudaBrute[MAX_BRUTE_LENGTH];
</div></li><li><div class="div0">&nbsp;__device__ __constant__ unsigned char cudaLeftSalt[MAX_SALT_LENGTH];
</div></li><li><div class="div1">&nbsp;__device__ __constant__ unsigned char cudaRightSalt[MAX_SALT_LENGTH];
</div></li><li><div class="div0">&nbsp;__device__ __constant__ unsigned char cudaCharSet[95];
</div></li><li><div class="div1">&nbsp;__device__ unsigned char correctPass[MAX_TOTAL];
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;#include &lt;stdio.h&gt;
</div></li><li><div class="div0">&nbsp;#include &lt;time.h&gt;
</div></li><li><div class="div1">&nbsp;#include &lt;stdlib.h&gt;

</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;#include "md5.cu" //This contains our MD5 helper functions
</div></li><li><div class="div0">&nbsp;#include "md5kernel.cu" //the CUDA thread
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;void checkCUDAError(const char *msg);
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;void ZeroFill(unsigned char* toFill, int length)
</div></li><li><div class="div1">&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0; 
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i = 0; i &lt; length; i++)
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toFill[i] = 0;
</div></li><li><div class="div1">&nbsp;}
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;bool BruteIncrement(unsigned char* brute, int setLen, int wordLength, int incrementBy)
</div></li><li><div class="div0">&nbsp;{

</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(incrementBy &gt; 0 &amp;&amp; i &lt; wordLength)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int add = incrementBy + brute[i];
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brute[i] = add % setLen;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incrementBy = add / setLen;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return incrementBy != 0; //we are done if there is a remainder, because we have looped over the max
</div></li><li><div class="div1">&nbsp;}

</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;int main( int argc, char** argv) 
</div></li><li><div class="div0">&nbsp;{
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int wordLength = 6;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int charSetLen = 0;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numThreads = BLOCKS * THREADS_PER_BLOCK;
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char currentBrute[MAX_BRUTE_LENGTH];
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char leftSalt[MAX_SALT_LENGTH];
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char rightSalt[MAX_SALT_LENGTH];
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char cpuCorrectPass[MAX_TOTAL];
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroFill(currentBrute, MAX_BRUTE_LENGTH);
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroFill(cpuCorrectPass, MAX_TOTAL);

</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroFill(leftSalt, MAX_SALT_LENGTH);
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroFill(rightSalt, MAX_SALT_LENGTH);
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//for this example, we will crack the hash of "http://ossbox.com"
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//we will use "http://" as the salt on the left and ".com" as the salt on the right
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//so our code has to brute force 'ossbox'
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charSetLen = 26;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char charSet[charSetLen];
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(charSet, "abcdefghijklmnopqrstuvwxyz", charSetLen);
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char hash[32];
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(hash, "91633d65575b2d47a7496707a93dc7e4", 32);
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(leftSalt, "http://", 7); 
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(rightSalt, ".com", 4);
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//turn the correct hash into it's four parts

</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint v1, v2, v3, v4;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;md5_to_ints(hash,&amp;v1,&amp;v2,&amp;v3,&amp;v4);
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//copy the salts to global
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaMemcpyToSymbol(cudaLeftSalt, &amp;leftSalt, MAX_SALT_LENGTH, 0, cudaMemcpyHostToDevice);
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaMemcpyToSymbol(cudaRightSalt, &amp;rightSalt, MAX_SALT_LENGTH, 0, cudaMemcpyHostToDevice);
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//zero the container used to hold the correct pass
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaMemcpyToSymbol(correctPass, &amp;cpuCorrectPass, MAX_TOTAL, 0, cudaMemcpyHostToDevice);
</div></li><li><div class="div1">&nbsp;

</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create and copy the charset to device
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaMemcpyToSymbol(cudaCharSet, &amp;charSet, charSetLen, 0, cudaMemcpyHostToDevice);
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool finished = false;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ct = 0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaMemcpyToSymbol(cudaBrute, &amp;currentBrute, MAX_BRUTE_LENGTH, 0, cudaMemcpyHostToDevice);
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//run the kernel
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim3 dimGrid(BLOCKS);
</div></li><li><div class="div0">&nbsp;    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim3 dimBlock(THREADS_PER_BLOCK);
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;crack&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(numThreads, charSetLen, wordLength, v1,v2,v3,v4);

</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the "correct pass" and see if there really is one
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaMemcpyFromSymbol(&amp;cpuCorrectPass, correctPass, MAX_TOTAL, 0, cudaMemcpyDeviceToHost);
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cpuCorrectPass[0] != 0)
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n\nFOUND: ");
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int k = 0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(cpuCorrectPass[k] != 0)
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%c", cpuCorrectPass[k]);
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k++;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finished = BruteIncrement(currentBrute, charSetLen, wordLength, numThreads * MD5_PER_KERNEL);
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkCUDAError("general");
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ct % OUTPUT_INTERVAL == 0)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("STATUS: ");
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int k = 0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(k = 0; k &lt; wordLength; k++)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%c",charSet[currentBrute[k]]);
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct++;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkCUDAError("mehhhh");

</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while(!finished);
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
</div></li><li><div class="div1">&nbsp;}
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;void checkCUDAError(const char *msg)
</div></li><li><div class="div0">&nbsp;{
</div></li><li><div class="div1">&nbsp;    cudaError_t err = cudaGetLastError();
</div></li><li><div class="div0">&nbsp;    if( cudaSuccess != err) 
</div></li><li><div class="div1">&nbsp;    {
</div></li><li><div class="div0">&nbsp;        fprintf(stderr, "Cuda error: %s: %s.\n", msg, cudaGetErrorString( err) );
</div></li><li><div class="div1">&nbsp;        exit(-1);

</div></li><li><div class="div0">&nbsp;    }                         
</div></li><li><div class="div1">&nbsp;}</div></li></ol></div>

<h2>md5kernel.cu</h2>
<div style="font-family: monospace;"><ol><li><div class="div0">&nbsp;//This is our CUDA thread
</div></li><li><div class="div1">&nbsp;//d_a is the word list array
</div></li><li><div class="div0">&nbsp;//maxidx is the maximum index in the array (if there are more threads than words)
</div></li><li><div class="div1">&nbsp;//v1 through v4 are the uint values of the correct md5 hash
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;__device__ void IncrementBruteGPU(unsigned char* ourBrute, uint charSetLen, uint bruteLength, uint incrementBy)
</div></li><li><div class="div0">&nbsp;{
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(incrementBy &gt; 0 &amp;&amp; i &lt; bruteLength)

</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int add = incrementBy + ourBrute[i];
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ourBrute[i] = add % charSetLen;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incrementBy = add / charSetLen;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div1">&nbsp;}
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;__global__ void crack(uint numThreads, uint charSetLen, uint bruteLength, uint v1, uint v2, uint v3, uint v4)
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;{
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//compute our index number
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;    &nbsp;&nbsp;&nbsp;&nbsp;uint idx = (blockIdx.x*blockDim.x + threadIdx.x);
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int totalLen = 0;

</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int bruteStart = 0;
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char word[MAX_TOTAL];
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char ourBrute[MAX_BRUTE_LENGTH];
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i = 0; i &lt; MAX_BRUTE_LENGTH; i++)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ourBrute[i] = cudaBrute[i];
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ary_i = 0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char tmp = 0;

</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((tmp = cudaLeftSalt[ary_i]) != 0)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word[i] = tmp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++; ary_i++;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bruteStart = i;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i+= bruteLength;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ary_i = 0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((tmp = cudaRightSalt[ary_i]) != 0)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word[i] = tmp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++; ary_i++;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalLen = i;
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IncrementBruteGPU(ourBrute, charSetLen, bruteLength, idx);
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int timer = 0;

</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(timer = 0; timer &lt; MD5_PER_KERNEL; timer++)
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Now, substitute the values into the string
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i = 0; i &lt; bruteLength; i++)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word[i+bruteStart] = cudaCharSet[ourBrute[i]];
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint c1 = 0, c2 = 0, c3 = 0, c4 = 0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the md5 hash of the word
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;md5_vfy(word,totalLen, &amp;c1, &amp;c2, &amp;c3, &amp;c4);

</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//compare hash with correct hash
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(c1 == v1 &amp;&amp; c2 == v2 &amp;&amp; c3 == v3 &amp;&amp; c4 == v4)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//put the correct password in the first indexes of the array, right after the sentinal
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int j;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j= 0; j &lt; MAX_TOTAL; j++)
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correctPass[j] = word[j];

</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correctPass[totalLen] = 0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IncrementBruteGPU(ourBrute, charSetLen, bruteLength, numThreads);
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;}
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;</div></li></ol></div>

<h2>md5.cu</h2>
<div style="font-family:monospace;"><ol><li><div class="div0">&nbsp;//
</div></li><li><div class="div1">&nbsp;// MD5 routines (straight from Wikipedia&#039;s MD5 pseudocode description)
</div></li><li><div class="div0">&nbsp;//
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;//////////////////////////////////////////////////////////////////////////////
</div></li><li><div class="div1">&nbsp;/////////////       Ron Rivest&#039;s MD5 C Implementation       //////////////////
</div></li><li><div class="div0">&nbsp;//////////////////////////////////////////////////////////////////////////////
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;/*

</div></li><li><div class="div1">&nbsp; **********************************************************************
</div></li><li><div class="div0">&nbsp; ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
</div></li><li><div class="div1">&nbsp; **                                                                  **
</div></li><li><div class="div0">&nbsp; ** License to copy and use this software is granted provided that   **
</div></li><li><div class="div1">&nbsp; ** it is identified as the &quot;RSA Data Security, Inc. MD5 Message     **
</div></li><li><div class="div0">&nbsp; ** Digest Algorithm&quot; in all material mentioning or referencing this **
</div></li><li><div class="div1">&nbsp; ** software or this function.                                       **

</div></li><li><div class="div0">&nbsp; **                                                                  **
</div></li><li><div class="div1">&nbsp; ** License is also granted to make and use derivative works         **
</div></li><li><div class="div0">&nbsp; ** provided that such works are identified as &quot;derived from the RSA **
</div></li><li><div class="div1">&nbsp; ** Data Security, Inc. MD5 Message Digest Algorithm&quot; in all         **
</div></li><li><div class="div0">&nbsp; ** material mentioning or referencing the derived work.             **
</div></li><li><div class="div1">&nbsp; **                                                                  **
</div></li><li><div class="div0">&nbsp; ** RSA Data Security, Inc. makes no representations concerning      **

</div></li><li><div class="div1">&nbsp; ** either the merchantability of this software or the suitability   **
</div></li><li><div class="div0">&nbsp; ** of this software for any particular purpose.  It is provided &quot;as **
</div></li><li><div class="div1">&nbsp; ** is&quot; without express or implied warranty of any kind.             **
</div></li><li><div class="div0">&nbsp; **                                                                  **
</div></li><li><div class="div1">&nbsp; ** These notices must be retained in any copies of any part of this **
</div></li><li><div class="div0">&nbsp; ** documentation and/or software.                                   **
</div></li><li><div class="div1">&nbsp; **********************************************************************

</div></li><li><div class="div0">&nbsp; */
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;/* F, G and H are basic MD5 functions: selection, majority, parity */
</div></li><li><div class="div0">&nbsp;#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))
</div></li><li><div class="div1">&nbsp;#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))
</div></li><li><div class="div0">&nbsp;#define H(x, y, z) ((x) ^ (y) ^ (z))
</div></li><li><div class="div1">&nbsp;#define I(x, y, z) ((y) ^ ((x) | (~z)))

</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;/* ROTATE_LEFT rotates x left n bits */
</div></li><li><div class="div0">&nbsp;#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
</div></li><li><div class="div1">&nbsp;/* Rotation is separate from addition to prevent recomputation */
</div></li><li><div class="div0">&nbsp;#define FF(a, b, c, d, x, s, ac) \
</div></li><li><div class="div1">&nbsp;  {(a) += F ((b), (c), (d)) + (x) + (uint)(ac); \
</div></li><li><div class="div0">&nbsp;   (a) = ROTATE_LEFT ((a), (s)); \
</div></li><li><div class="div1">&nbsp;   (a) += (b); \

</div></li><li><div class="div0">&nbsp;  }
</div></li><li><div class="div1">&nbsp;#define GG(a, b, c, d, x, s, ac) \
</div></li><li><div class="div0">&nbsp;  {(a) += G ((b), (c), (d)) + (x) + (uint)(ac); \
</div></li><li><div class="div1">&nbsp;   (a) = ROTATE_LEFT ((a), (s)); \
</div></li><li><div class="div0">&nbsp;   (a) += (b); \
</div></li><li><div class="div1">&nbsp;  }
</div></li><li><div class="div0">&nbsp;#define HH(a, b, c, d, x, s, ac) \
</div></li><li><div class="div1">&nbsp;  {(a) += H ((b), (c), (d)) + (x) + (uint)(ac); \
</div></li><li><div class="div0">&nbsp;   (a) = ROTATE_LEFT ((a), (s)); \
</div></li><li><div class="div1">&nbsp;   (a) += (b); \

</div></li><li><div class="div0">&nbsp;  }
</div></li><li><div class="div1">&nbsp;#define II(a, b, c, d, x, s, ac) \
</div></li><li><div class="div0">&nbsp;  {(a) += I ((b), (c), (d)) + (x) + (uint)(ac); \
</div></li><li><div class="div1">&nbsp;   (a) = ROTATE_LEFT ((a), (s)); \
</div></li><li><div class="div0">&nbsp;   (a) += (b); \
</div></li><li><div class="div1">&nbsp;  }
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;__device__ void md5_vfy(unsigned char* data, uint length, uint *a1, uint *b1, uint *c1, uint *d1)
</div></li><li><div class="div0">&nbsp;{
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint a0 = 0x67452301;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint b0 = 0xEFCDAB89;

</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint c0 = 0x98BADCFE;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint d0 = 0x10325476;
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint a = 0;
</div></li><li><div class="div0">&nbsp;    uint b = 0;
</div></li><li><div class="div1">&nbsp;    uint c = 0;
</div></li><li><div class="div0">&nbsp;    uint d = 0;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;uint vals[14] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;int i = 0;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;for(i=0; i &lt; length; i++)

</div></li><li><div class="div1">&nbsp;{
</div></li><li><div class="div0">&nbsp;    vals[i / 4] |= data[i] &lt;&lt; ((i % 4) * 8);
</div></li><li><div class="div1">&nbsp;}
</div></li><li><div class="div0">&nbsp;vals[i / 4] |= 0x80 &lt;&lt; ((i % 4) * 8);
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;uint bitlen = length * 8;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;#define in0  (vals[0])//x
</div></li><li><div class="div1">&nbsp;#define in1  (vals[1])//y
</div></li><li><div class="div0">&nbsp;#define in2  (vals[2])//z
</div></li><li><div class="div1">&nbsp;#define in3  (vals[3])
</div></li><li><div class="div0">&nbsp;#define in4  (vals[4])

</div></li><li><div class="div1">&nbsp;#define in5  (vals[5])
</div></li><li><div class="div0">&nbsp;#define in6  (vals[6])
</div></li><li><div class="div1">&nbsp;#define in7  (vals[7])
</div></li><li><div class="div0">&nbsp;#define in8  (vals[8])
</div></li><li><div class="div1">&nbsp;#define in9  (vals[9])
</div></li><li><div class="div0">&nbsp;#define in10 (vals[10])
</div></li><li><div class="div1">&nbsp;#define in11 (vals[11])
</div></li><li><div class="div0">&nbsp;#define in12 (vals[12])
</div></li><li><div class="div1">&nbsp;#define in13 (vals[13])
</div></li><li><div class="div0">&nbsp;#define in14 (bitlen) //w = bit length
</div></li><li><div class="div1">&nbsp;#define in15 (0)
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Initialize hash value for this chunk:
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = a0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = b0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = c0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = d0;

</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;  /* Round 1 */
</div></li><li><div class="div1">&nbsp;#define S11 7
</div></li><li><div class="div0">&nbsp;#define S12 12
</div></li><li><div class="div1">&nbsp;#define S13 17
</div></li><li><div class="div0">&nbsp;#define S14 22
</div></li><li><div class="div1">&nbsp;  FF ( a, b, c, d, in0,  S11, 3614090360); /* 1 */
</div></li><li><div class="div0">&nbsp;  FF ( d, a, b, c, in1,  S12, 3905402710); /* 2 */
</div></li><li><div class="div1">&nbsp;  FF ( c, d, a, b, in2,  S13,  606105819); /* 3 */
</div></li><li><div class="div0">&nbsp;  FF ( b, c, d, a, in3,  S14, 3250441966); /* 4 */
</div></li><li><div class="div1">&nbsp;  FF ( a, b, c, d, in4,  S11, 4118548399); /* 5 */

</div></li><li><div class="div0">&nbsp;  FF ( d, a, b, c, in5,  S12, 1200080426); /* 6 */
</div></li><li><div class="div1">&nbsp;  FF ( c, d, a, b, in6,  S13, 2821735955); /* 7 */
</div></li><li><div class="div0">&nbsp;  FF ( b, c, d, a, in7,  S14, 4249261313); /* 8 */
</div></li><li><div class="div1">&nbsp;  FF ( a, b, c, d, in8,  S11, 1770035416); /* 9 */
</div></li><li><div class="div0">&nbsp;  FF ( d, a, b, c, in9,  S12, 2336552879); /* 10 */
</div></li><li><div class="div1">&nbsp;  FF ( c, d, a, b, in10, S13, 4294925233); /* 11 */
</div></li><li><div class="div0">&nbsp;  FF ( b, c, d, a, in11, S14, 2304563134); /* 12 */
</div></li><li><div class="div1">&nbsp;  FF ( a, b, c, d, in12, S11, 1804603682); /* 13 */
</div></li><li><div class="div0">&nbsp;  FF ( d, a, b, c, in13, S12, 4254626195); /* 14 */

</div></li><li><div class="div1">&nbsp;  FF ( c, d, a, b, in14, S13, 2792965006); /* 15 */
</div></li><li><div class="div0">&nbsp;  FF ( b, c, d, a, in15, S14, 1236535329); /* 16 */
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;  /* Round 2 */
</div></li><li><div class="div1">&nbsp;#define S21 5
</div></li><li><div class="div0">&nbsp;#define S22 9
</div></li><li><div class="div1">&nbsp;#define S23 14
</div></li><li><div class="div0">&nbsp;#define S24 20
</div></li><li><div class="div1">&nbsp;  GG ( a, b, c, d, in1, S21, 4129170786); /* 17 */
</div></li><li><div class="div0">&nbsp;  GG ( d, a, b, c, in6, S22, 3225465664); /* 18 */
</div></li><li><div class="div1">&nbsp;  GG ( c, d, a, b, in11, S23,  643717713); /* 19 */

</div></li><li><div class="div0">&nbsp;  GG ( b, c, d, a, in0, S24, 3921069994); /* 20 */
</div></li><li><div class="div1">&nbsp;  GG ( a, b, c, d, in5, S21, 3593408605); /* 21 */
</div></li><li><div class="div0">&nbsp;  GG ( d, a, b, c, in10, S22,   38016083); /* 22 */
</div></li><li><div class="div1">&nbsp;  GG ( c, d, a, b, in15, S23, 3634488961); /* 23 */
</div></li><li><div class="div0">&nbsp;  GG ( b, c, d, a, in4, S24, 3889429448); /* 24 */
</div></li><li><div class="div1">&nbsp;  GG ( a, b, c, d, in9, S21,  568446438); /* 25 */
</div></li><li><div class="div0">&nbsp;  GG ( d, a, b, c, in14, S22, 3275163606); /* 26 */
</div></li><li><div class="div1">&nbsp;  GG ( c, d, a, b, in3, S23, 4107603335); /* 27 */
</div></li><li><div class="div0">&nbsp;  GG ( b, c, d, a, in8, S24, 1163531501); /* 28 */

</div></li><li><div class="div1">&nbsp;  GG ( a, b, c, d, in13, S21, 2850285829); /* 29 */
</div></li><li><div class="div0">&nbsp;  GG ( d, a, b, c, in2, S22, 4243563512); /* 30 */
</div></li><li><div class="div1">&nbsp;  GG ( c, d, a, b, in7, S23, 1735328473); /* 31 */
</div></li><li><div class="div0">&nbsp;  GG ( b, c, d, a, in12, S24, 2368359562); /* 32 */
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;  /* Round 3 */
</div></li><li><div class="div1">&nbsp;#define S31 4
</div></li><li><div class="div0">&nbsp;#define S32 11
</div></li><li><div class="div1">&nbsp;#define S33 16
</div></li><li><div class="div0">&nbsp;#define S34 23
</div></li><li><div class="div1">&nbsp;  HH ( a, b, c, d, in5, S31, 4294588738); /* 33 */

</div></li><li><div class="div0">&nbsp;  HH ( d, a, b, c, in8, S32, 2272392833); /* 34 */
</div></li><li><div class="div1">&nbsp;  HH ( c, d, a, b, in11, S33, 1839030562); /* 35 */
</div></li><li><div class="div0">&nbsp;  HH ( b, c, d, a, in14, S34, 4259657740); /* 36 */
</div></li><li><div class="div1">&nbsp;  HH ( a, b, c, d, in1, S31, 2763975236); /* 37 */
</div></li><li><div class="div0">&nbsp;  HH ( d, a, b, c, in4, S32, 1272893353); /* 38 */
</div></li><li><div class="div1">&nbsp;  HH ( c, d, a, b, in7, S33, 4139469664); /* 39 */
</div></li><li><div class="div0">&nbsp;  HH ( b, c, d, a, in10, S34, 3200236656); /* 40 */
</div></li><li><div class="div1">&nbsp;  HH ( a, b, c, d, in13, S31,  681279174); /* 41 */
</div></li><li><div class="div0">&nbsp;  HH ( d, a, b, c, in0, S32, 3936430074); /* 42 */

</div></li><li><div class="div1">&nbsp;  HH ( c, d, a, b, in3, S33, 3572445317); /* 43 */
</div></li><li><div class="div0">&nbsp;  HH ( b, c, d, a, in6, S34,   76029189); /* 44 */
</div></li><li><div class="div1">&nbsp;  HH ( a, b, c, d, in9, S31, 3654602809); /* 45 */
</div></li><li><div class="div0">&nbsp;  HH ( d, a, b, c, in12, S32, 3873151461); /* 46 */
</div></li><li><div class="div1">&nbsp;  HH ( c, d, a, b, in15, S33,  530742520); /* 47 */
</div></li><li><div class="div0">&nbsp;  HH ( b, c, d, a, in2, S34, 3299628645); /* 48 */
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;  /* Round 4 */
</div></li><li><div class="div1">&nbsp;#define S41 6
</div></li><li><div class="div0">&nbsp;#define S42 10

</div></li><li><div class="div1">&nbsp;#define S43 15
</div></li><li><div class="div0">&nbsp;#define S44 21
</div></li><li><div class="div1">&nbsp;  II ( a, b, c, d, in0, S41, 4096336452); /* 49 */
</div></li><li><div class="div0">&nbsp;  II ( d, a, b, c, in7, S42, 1126891415); /* 50 */
</div></li><li><div class="div1">&nbsp;  II ( c, d, a, b, in14, S43, 2878612391); /* 51 */
</div></li><li><div class="div0">&nbsp;  II ( b, c, d, a, in5, S44, 4237533241); /* 52 */
</div></li><li><div class="div1">&nbsp;  II ( a, b, c, d, in12, S41, 1700485571); /* 53 */
</div></li><li><div class="div0">&nbsp;  II ( d, a, b, c, in3, S42, 2399980690); /* 54 */
</div></li><li><div class="div1">&nbsp;  II ( c, d, a, b, in10, S43, 4293915773); /* 55 */
</div></li><li><div class="div0">&nbsp;  II ( b, c, d, a, in1, S44, 2240044497); /* 56 */

</div></li><li><div class="div1">&nbsp;  II ( a, b, c, d, in8, S41, 1873313359); /* 57 */
</div></li><li><div class="div0">&nbsp;  II ( d, a, b, c, in15, S42, 4264355552); /* 58 */
</div></li><li><div class="div1">&nbsp;  II ( c, d, a, b, in6, S43, 2734768916); /* 59 */
</div></li><li><div class="div0">&nbsp;  II ( b, c, d, a, in13, S44, 1309151649); /* 60 */
</div></li><li><div class="div1">&nbsp;  II ( a, b, c, d, in4, S41, 4149444226); /* 61 */
</div></li><li><div class="div0">&nbsp;  II ( d, a, b, c, in11, S42, 3174756917); /* 62 */
</div></li><li><div class="div1">&nbsp;  II ( c, d, a, b, in2, S43,  718787259); /* 63 */
</div></li><li><div class="div0">&nbsp;  II ( b, c, d, a, in9, S44, 3951481745); /* 64 */
</div></li><li><div class="div1">&nbsp;

</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a += a0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b += b0;
</div></li><li><div class="div0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c += c0;
</div></li><li><div class="div1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d += d0;
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;    *a1 = a;
</div></li><li><div class="div0">&nbsp;    *b1 = b;
</div></li><li><div class="div1">&nbsp;    *c1 = c;
</div></li><li><div class="div0">&nbsp;    *d1 = d;
</div></li><li><div class="div1">&nbsp;}
</div></li><li><div class="div0">&nbsp;
</div></li><li><div class="div1">&nbsp;uint unhex(unsigned char x)
</div></li><li><div class="div0">&nbsp;{

</div></li><li><div class="div1">&nbsp;    if(x &lt;= &#039;F&#039; &amp;&amp; x &gt;= &#039;A&#039;)
</div></li><li><div class="div0">&nbsp;    {
</div></li><li><div class="div1">&nbsp;        return  (uint)(x - &#039;A&#039; + 10);

</div></li><li><div class="div0">&nbsp;    }
</div></li><li><div class="div1">&nbsp;    else if(x &lt;= &#039;f&#039; &amp;&amp; x &gt;= &#039;a&#039;)
</div></li><li><div class="div0">&nbsp;    {
</div></li><li><div class="div1">&nbsp;        return (uint)(x - &#039;a&#039; + 10);

</div></li><li><div class="div0">&nbsp;    }
</div></li><li><div class="div1">&nbsp;    else if(x &lt;= &#039;9&#039; &amp;&amp; x &gt;= &#039;0&#039;)
</div></li><li><div class="div0">&nbsp;    {
</div></li><li><div class="div1">&nbsp;        return (uint)(x - &#039;0&#039;);

</div></li><li><div class="div0">&nbsp;    }
</div></li><li><div class="div1">&nbsp;    return 0;
</div></li><li><div class="div0">&nbsp;}
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;void md5_to_ints(unsigned char* md5, uint *r0, uint *r1, uint *r2, uint *r3)
</div></li><li><div class="div1">&nbsp;{
</div></li><li><div class="div0">&nbsp;    uint v0 = 0, v1 = 0, v2 = 0, v3 = 0;
</div></li><li><div class="div1">&nbsp;    int i = 0;
</div></li><li><div class="div0">&nbsp;    for(i = 0; i &lt; 32; i+=2)
</div></li><li><div class="div1">&nbsp;    {

</div></li><li><div class="div0">&nbsp;        uint first = unhex(md5[i]);
</div></li><li><div class="div1">&nbsp;        uint second = unhex(md5[i+1]);
</div></li><li><div class="div0">&nbsp;        uint both = first * 16 + second;
</div></li><li><div class="div1">&nbsp;        both = both &lt;&lt; 24;
</div></li><li><div class="div0">&nbsp;        if(i &lt; 8)
</div></li><li><div class="div1">&nbsp;        {
</div></li><li><div class="div0">&nbsp;            v0 = (v0 &gt;&gt; 8 ) | both;

</div></li><li><div class="div1">&nbsp;        }
</div></li><li><div class="div0">&nbsp;        else if (i &lt; 16)
</div></li><li><div class="div1">&nbsp;        {
</div></li><li><div class="div0">&nbsp;            v1 = (v1 &gt;&gt; 8) | both;
</div></li><li><div class="div1">&nbsp;        }
</div></li><li><div class="div0">&nbsp;        else if (i &lt; 24)

</div></li><li><div class="div1">&nbsp;        {
</div></li><li><div class="div0">&nbsp;            v2 = (v2 &gt;&gt; 8) | both;
</div></li><li><div class="div1">&nbsp;        }
</div></li><li><div class="div0">&nbsp;        else if(i &lt; 32)
</div></li><li><div class="div1">&nbsp;        {
</div></li><li><div class="div0">&nbsp;            v3 = (v3 &gt;&gt; 8) | both;

</div></li><li><div class="div1">&nbsp;        }
</div></li><li><div class="div0">&nbsp;    }
</div></li><li><div class="div1">&nbsp;
</div></li><li><div class="div0">&nbsp;    *r0 = v0;
</div></li><li><div class="div1">&nbsp;    *r1 = v1;
</div></li><li><div class="div0">&nbsp;    *r2 = v2;
</div></li><li><div class="div1">&nbsp;    *r3 = v3;
</div></li><li><div class="div0">&nbsp;}
</div></li><li><div class="div1">&nbsp;</div></li></ol></div>
