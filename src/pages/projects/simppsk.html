<h1>SimpPSK</h1>
<p>SimpPSK is an easy to use pre-shared key authentication and session key exchange protocol. SimpPSK allows two parties who <b>already share a secret key</b>, to authenticate to each other and create a session key. It also allows both parties to agree on a hash algorithm and encryption algorithm, so weak ciphers/hashes can be phased out gradually. This key can then be used for encrypted communications. Full C++ Windows and UNIX source code is available.</p>

<p>SimpPSK, including the C++ code provided here, is not and never will be patented, copyrighted, or protected in any way. It is, and always will be free for anyone to use for whatever purpose.</p>
<h2>Description</h2>
<p>The "protocol" combines random data from both parties and their PSK to create a session key. Then each one is challenged by the other to prove they have the same session key.</p>

<h3>Crypto (from simppsk.h):</h3>
<p>The client and server would authenticate like this:</p>
<ol>
<li>Client generates 256 random bits, and sends it to the server (unencrypted)</li>
<li>Server generates a different random 256 bits, and sends it back to the client</li>
<li>Now Client and Server each have 512 bits of the same randomness, 256 of which was generated by themselves so if there was a man in the middle modifying their communications, the following steps will fail:</li>
<li> Client concatenates (NOT XOR OR ADDITION, CONCATINATION) the two 256 parts together to form a 512 bit string.</li>
<li> Client computes sessionKey = H(password . random512Bits). The '.' means concatenation. H is a secure hash algorithm, like SHA256</li>
<li> Server does that same computation, and will obtain the same session key.</li>
</ol>

<p>Once they both have the session key, they can easily authenticate by:</p>

<ol start="7">
<li>Client generates 256 random bits, sends them to the server.</li>
<li>Server computes H(randomBits . sessionKey) and sends the answer back to the client</li>
<li>Client computes the same H(randomBits . sessionKey) and verfies that it is the same as what the server said</li>
<li>repeat the process to authenticate the client to the server</li>
</ol>

<h4>Security Arguments:</h4>
<ul>
<li>Each party gets to choose their own random numbers, they never have to trust any unencrypted data sent over the wire.</li>
<li>If an attacker modifies any bit of the random number exchanges, the sessions keys will end up being different.</li>
<li>Client and Server's random numbers are concatenated, NOT XOR'd, so an attacker can't make them the same so they XOR to 000000..</li>
<li>An attacker can't MITM the protocol because he does not know the pre-shared key. He would not be able to give a valid response to the challenges.</li>
<li>Session key is created with random data from both parties, so it is different every time, and one party doesn't have to trust the other's CSPRNG.</li>
</ul>
<h4>Implementation:</h4>

<p>This is done using a 3 way handshake. First, the client sends an AuthRequest to the server.
The server accepts the AuthRequest and replies with an AuthReply. The client accepts the
AuthReply and then sends the AuthFinalize to the server.After this is done, the client and
server now share a session key and have validated each other's identity.</p>

<h2>Source Code (v0.8)</h2>
<h3>Notes</h3>
<ul>
	<li><b>This hasn't had any peer review for remote code execution exploits.</b></li>
	<li>This includes only the key exchange code, the encryption code hasn't been finished yet.</li>
	<li><a href="pages/projects/simppsk_review1.txt">Peer Review 1</a></li>
</ul>
<h3>Download</h3>
<ul>
	<li><a href="source/SimpPSKv0.8.tar.gz">v0.8 - Win32/UNIX C++ Code::Blocks Project</a></li>
</ul>
<br /><br />
