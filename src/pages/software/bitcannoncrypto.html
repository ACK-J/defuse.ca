<h1><a href="/bitcannon.htm">BitCannon</a> Cryptography</h1>
The following is a description of how peers in BitCannon establish and maintain a secure communication stream. The choice to design this protocol over using the standard TLS was made because the .NET framework does not include APIs for cross-platform TLS connections and generating certificates.
<br /><br />
I assure you, that in designing this protocol, I thoroughly researched the topic of secure and authenticated communication over insecure networks. This included reading the <a href="http://tools.ietf.org/html/rfc5246">TLS v1.2 specification</a> and the <a href="http://www.ietf.org/rfc/rfc4253.txt" >SSH specification</a>. There is nothing "new" or "special" in this protocol, it's design is based on well-known and well-trusted crypto. There is a lot of poorly implemented crypto on the net so it is a good thing to be HIGHLY critical of "custom made" protocols, but after you read this page you should be able to trust this protocol.
<br /><br />
Cryptographers: Feel free to review of this cryptosystem and email me your comments. I will post them on this page.
<h2>Crypto Primer</h2>
Before we dive deep into the world of crypto, you should get a good understanding of what cryptography is and how it works. Here are a few episodes of the <a href="http://grc.com/securitynow.htm">SecurityNow!</a> podcast that provide a GREAT explanation of basic cryptography.
<br /><br />
<ul>
	<li><a href="http://media.grc.com/sn/sn-030.mp3">SecurityNow! #30 - Cryptographic Issues (30 minutes, 14MB)</a></li>
	<li><a href="http://media.grc.com/sn/sn-031.mp3">SecurityNow! #31 - Symmetric Stream Ciphers (53 minutes, 25MB)</a></li>
	<li><a href="http://media.grc.com/sn/sn-033.mp3">SecurityNow! #33 - Symmetric Block Ciphers (43 minutes, 21MB)</a></li>
	<li><a href="http://media.grc.com/sn/sn-034.mp3">SecurityNow! #34 - Public Key Cryptography (37 minutes, 18MB)</a></li>
	<li><a href="http://grc.com/securitynow.htm">More Episodes</a></li>
</ul>
<h2>Functionality Overview</h2>
Each new install of BitCannon will generate an 4096 bit RSA public/private key pair. When BitCannon is run, it will securely connect to the central server (using the protocol described here) and request an ID. The server will receive the client's public key, generate a unique ID, and sign the ID and client's public key togeather, and send the signature back to the BitCannon client. The server takes care to only ever sign one public key to an ID, so peers can use the signatures to verify which public key belongs to an ID.
<br /><br />
This PKI system is very similar to SSL/TLS, the central server is the Certificate Authority. The signing process generates a signature string, which can be used by a peer to prove his public key was signed by the server for his ID.  
<br /><br />
When a peer wants to send a file to another peer, he sends a request to the server asking for the second peer's IP address and port number. The server replies, and the peer attempts to connect to that IP and port. If the connection was successful, the two peers will engage in a secure handshake to exchange a secret key that will be used to encrypt and sign data.
<h2>Handshake</h2>

<h3>Security of the Handshake</h3>
<h4>MITM and Replay Attacks</h4>
<h4>Side Channel Attacks</h4>
<h2>Data Stream Encryption</h2>
Now that both peers share a secret key, symmetric cryptography can be used to encrypt the data being sent between peers. TCP connections are represented as a continuous stream of bytes, so to provide proper encryption and authentication, the stream must be broken into discrete units. For this explanation, I'll call these units "CryptoPackets". CryptoPackets provide both encryption and authentication of one section of the stream. 

<h3>CryptoPackets</h3>
CryptoPackets simply represent a division of the byte stream between two peers. CryptoPackets can contain up to 10KB of data. Each new CryptoPacket is given the value of a 64 bit counter, which gets incremented everytime a CryptoPacket is created. The counter value is used to prevent the same CryptoPacket from being replayed by an attacker. Each CryptoPacket is also given a "direction" value, which is used to prevent an attacker from being able to replay a CryptoPacket back to the sender.

<br /><br />
When a CryptoPacket is sent, the following process is used to encrypt and authenticate the data:

<br />
<h4>Encryption</h4>
<ul>
	<li>The AES block cipher is initialized with the session_data_key.</li>
	<li>A random 128 bit IV (Initialization Vector) is generated.</li>
	<li>The data is encrypted with AES in CBC mode using the IV generated in the previous step.</li>
	<li>An HMAC (SHA256), keyed with session_hmac_key, is used to sign the IV, ciphertext, ciphertext length, packet direction, and the sequence number.</li>
	<li>The IV, ciphertext length, ciphertext, and HMAC are sent across the network.</li>
</ul>
<h4>Decryption</h4>
<ul>
	<li>The IV, ciphertext, and checksum are received from the network.</li>
	<li>The HMAC of the IV, ciphertext, ciphertext length, expected packet direction, and expected sequence number is generated and checked against the HMAC received from the network. If they do not match, the connection is broken.</li>
	<li>If the HMAC validation was successful, the IV is used with AES to decrypt the ciphertext, and the plaintext is appended to the read buffer.</li>
</ul>

<h3>Rekeying</h3>
<!--	every 1MB, mention avalanche effect-->

<h3>Security of the Data Stream Encryption</h3>
<h4>MITM and Replay Attacks</h4>
<h4>Side Channel Attacks</h4>
AES is vulnerable to <a href="http://cr.yp.to/antiforgery/cachetiming-20050414.pdf">timing attacks</a>, so we must analyze what timing information an attacker (MITM) will be able to gain. If the attacker can predict when the encryption operation started, he will be able to measure the amount of time it took to encrypt the plaintext. This can lead to key recovery over time, but since the key is changed regularly, there risk of an attacker discovering the secret key is much less.

<h2>Random Number Generation</h2>

